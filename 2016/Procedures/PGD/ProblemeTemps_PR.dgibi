AAEZ
PR_ProblemeTemps
DEBPROC PR_ProblemeTemps M C K Ttot schema CHA dt f It_m ;

* Creer un procedure pour le schema
  alpha = 0.;
  beta = 1./4;
  gamma = 1./2;

* Cette partie ne pourra plus etre hors de la boucle en non lineaire
  Prem_g = XTMX f_espa K ;
  Prem_gp = XTMX f_espa C ;
  Prem_gpp = XTMX f_espa M ;

    NbCharg = DIMENSION CHA ;
    Bool1 = (NbCharg > 0);

    Si Bool1;
        REPETER It_T NbCharg ;
          CHA_i = EXTR CHA CHAR &It_T ;
          CHP_i = EXTR CHA_i CHAM ;

          FOR_proj = XTY CHP_i f LFOR L_f;

          EVO_i = EXTR CHA_i EVOL ;

          Si (&It_T ega 1) ;
            FOR_EVO = EVO_i*FOR_proj ;
          SiNon ;
            FOR_EVO = FOR_EVO + (EVO_i * FOR_proj) ;
          FinSi ;
        FIN It_T ;

        F_Hist = EXTR FOR_EVO ORDO ;

        F_Hist2 = (PROG (EXTR F_Hist 1)) et F_Hist;
        F_Hist2 = ENLEVER F_Hist2 (DIMENSION F_Hist2);

        Second = ((1+alpha)*F_Hist) - (alpha*F_Hist2);
    FinSi ;

    Si ( Nb_NL > 0) ;
        FNL_proj = TABLE ;
        UNL_proj = TABLE ;
        TabLisNL = TABLE ;

        REPETER It_NL Nb_NL ;
            FNL_proj.&It_NL = XTY (Pb.Tab_NL.&It_NL.effo) f LFOR L_f ;

            Si ( EXISTE (Pb.Tab_NL.&It_NL) Poi_int ) ;
                UNL_proj.&It_NL = (EXTR f (Pb.Tab_NL.&It_NL.Dir_int)
                  (Pb.Tab_NL.&It_NL.Poi_int)) * (Pb.Tab_NL.&It_NL.fac_int) ;
            SiNon ;
                UNL_proj.&It_NL = XTY (Pb.Tab_NL.&It_NL.ch_depen) f LFOR L_f;
            FinSi ;
            TabLisNL.&It_NL = PROG ;
        Fin It_NL ;
    FinSi ;

    FamiFTot FamiGTot = PR_ConcatenerFami (It_m-1) ;

* Contribution des modes precendents

    TailFami = DIMENSION FamiFTot;

    Si (TailFami > 0);
        REPETER Mod TailFami;
            gk = FamiGTot.&Mod;
            fk = FamiFTot.&Mod;

            // DEFA = ((DEFO Pb.geo (fk * 0.) ) ET
            //         (DEFO Pb.geo fk ROUG));
            // Trac DEFA;

            f_K_fk = YTMX f fk K;
            f_C_fk = YTMX f fk C;
            f_M_fk = YTMX f fk M;

            Si (&Mod ega 1) ;
                ModsPrec = (f_K_fk * gk.u) + (f_C_fk * gk.v) + (f_M_fk * gk.w) ;
                // list ModsPrec;
            SiNon ;
                ModsPrec = ModsPrec +
                            (f_K_fk * gk.u) + (f_C_fk * gk.v) + (f_M_fk * gk.w);
            FinSi ;
        Fin Mod;

        Si Bool1;
            Second = Second - ModsPrec;
        SiNon ;
            Second = (-1) * ModsPrec;
        FinSi ;
    FinSi ;

    Si ((NON Bool1) ET (NON (TailFami > 0)));
        Mess 'il n y a ni effort ni deplacements imposes';
        Mess '--------------------------------------------';
        list CHA.1;
    FinSi ;

    g = PROG ;
    gp = PROG ;
    gpp = PROG ;

    REPETER It_T En_Nb_Re;

        Si (&It_T ega 1);
            g_t = 0. ;
            gp_t = 0. ;
            g__tm1 = 0. ;
            gp__tm1 = 0. ;
            gpp_t = 0. ;
            g_pred = 0. ;
            gp_pred = 0. ;
        SiNon ;
            g_pred = g_t + ((1+alpha)*((dt*gp_t) + ((dt**2)*(0.5-beta)*gpp_t)));
            gp_pred = gp_t + ((1+alpha)*dt*(1-gamma)*gpp_t ) ;
        FinSi ;

      SecondT = EXTR Second &It_T ;


        Si ( Nb_NL > 0) ;
            gpp_t gp_t g_t = PR_Pt_Fx_NL SecondT &It_T 'PGD' PGDPt_Fx ;
        SiNon ;
            gpp_t gp_t g_t = PR_ResolutionHHT_PGDLineaire SecondT &It_T;
        FinSi ;


        g =   g   et (PROG g_t  ) ;
        gp =  gp  et (PROG gp_t ) ;
        gpp = gpp et (PROG gpp_t) ;

        g__tm1 = g_t ;
        gp__tm1 = gp_t ;

    Fin It_T ;

    g_tmps = TABLE;
    g_tmps.u = g;
    g_tmps.v = gp;
    g_tmps.w = gpp;

    // DESS (EVOL MANU T Vec_T F(T) g) ;

  RESPRO g_tmps;

  TabEvoNL = TABLE ;
  Si ( Nb_NL > 0) ;
    REPETER It_NL Nb_NL ;
        TabEvoNL.&It_NL = EVOL MANU T Vec_T F(T) (TabLisNL.&It_NL) ;
    Fin It_NL ;
  FinSi ;
  RESPRO TabEvoNL ;

FINPROC;
