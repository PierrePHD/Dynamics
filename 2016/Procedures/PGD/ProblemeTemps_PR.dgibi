AAEZ
PR_ProblemeTemps
DEBPROC PR_ProblemeTemps M C K Ttot schema CHA dt f It_m ;

* Creer un procedure pour le schema
  alpha = 0.;
  beta = 1./4;
  gamma = 1./2;

* Cette partie ne pourra plus etre hors de la boucle en non lineaire
  Prem_g = XTMX f_espa K ;
  Prem_gp = XTMX f_espa C ;
  Prem_gpp = XTMX f_espa M ;

    g = PROG ;
    gp = PROG ;
    gpp = PROG ;

    NbCharg = DIMENSION CHA ;
    REPETER It NbCharg ;
      CHA_i = EXTR CHA CHAR &It ;
      CHP = EXTR CHA_i CHAM ;

      LFOR = MOTS FX FY FZ FR FT MX MY MZ MT ;
      L_f = MOTS UX UY UZ UR UT RX RY RZ RT ;
      FOR_proj = XTY CHP f LFOR L_f;

      EVO = EXTR CHA_i EVOL ;

      Si (&It ega 1) ;
        FOR_EVO = EVO*FOR_proj ;
      Sinon ;
        FOR_EVO = FOR_EVO + (EVO * FOR_proj) ;
      FinSi ;
    FIN It ;

* Verifier que l evolution final amene a Ttot avec En_Nb_Re composantes

    F_Hist = EXTR FOR_EVO ORDO ;

    F_Hist2 = (PROG (EXTR F_Hist 1)) et F_Hist;
    F_Hist2 = ENLEVER F_Hist2 (DIMENSION F_Hist2);

    Second = ((1+alpha)*F_Hist) - (alpha*F_Hist2);

    FamiFTot FamiGTot = PR_ConcatenerFami (It_m-1) ;

    Bool = (DIMENSION FamiFTot) > 0;
    Si Bool;
        TailFami = DIMENSION FamiFTot;
        REPETER Mod TailFami;
            gk = FamiGTot.&Mod;
            fk = FamiFTot.&Mod;
            f_K_fk = YTMX f fk K;
            f_C_fk = YTMX f fk C;
            f_M_fk = YTMX f fk M;

            Si (&Mod ega 1) ;
                ModsPrec = (f_K_fk * gk.u) + (f_C_fk * gk.v) + (f_M_fk * gk.w) ;
            Sinon ;
                ModsPrec = ModsPrec +
                            (f_K_fk * gk.u) + (f_C_fk * gk.v) + (f_M_fk * gk.w);
            FinSi ;
        Fin Mod;
    FinSi;

    * Contribution des modes precendents
    Si (It_m > 1);
      Second = Second - ModsPrec;
    FinSi;

    REPETER It En_Nb_Re;

      Si (&It ega 1);
        g_t = 0. ;
        gp_t = 0. ;
        gpp_t = 0. ;
        g_pred = 0. ;
        gp_pred = 0. ;
      SiNon;
        g_pred = g_t + ((1+alpha)*((dt*gp_t) + ((dt**2)*(0.5-beta)*gpp_t)));
        gp_pred = gp_t + ((1+alpha)*dt*(1-gamma)*gpp_t ) ;
      FinSi;

      SecondT = EXTR Second &It ;

      gpp_t_pr = gpp_t;
      gpp_t = (SecondT - ((Prem_g*g_pred)+(Prem_gp*gp_pred)))/Prem_gpp;

      Si (&It neg 1) ;
        g_t = g_t + (dt*gp_t)
                + ((dt**2)*(0.5-beta)*gpp_t_pr)
                + (beta*(dt**2)*gpp_t) ;
        gp_t = gp_t + (dt*(1-gamma)*gpp_t_pr) + (dt*gamma*gpp_t) ;
      FinSi;

        g =   g   et (PROG g_t  ) ;
        gp =  gp  et (PROG gp_t ) ;
        gpp = gpp et (PROG gpp_t) ;

    Fin It ;

    g_tmps = TABLE;
    g_tmps.u = g;
    g_tmps.v = gp;
    g_tmps.w = gpp;

  RESPRO g_tmps;

FINPROC;
