AAEZ
PR_ProblemeTemps
DEBPROC PR_ProblemeTemps M C K Ttot schema CHA dt f It_m ;

* Creer un procedure pour le schema
  alpha = 0.;
  beta = 1./4;
  gamma = 1./2;

* Cette partie ne pourra plus etre hors de la boucle en non lineaire
  Prem_g = XTMX f_espa K ;
  Prem_gp = XTMX f_espa C ;
  Prem_gpp = XTMX f_espa M ;

    NbCharg = DIMENSION CHA ;
    Bool1 = (NbCharg > 0);

    Si Bool1;
        REPETER It NbCharg ;
          CHA_i = EXTR CHA CHAR &It ;
          CHP_i = EXTR CHA_i CHAM ;

          FOR_proj = XTY CHP_i f LFOR L_f;

          EVO_i = EXTR CHA_i EVOL ;

          Si (&It ega 1) ;
            FOR_EVO = EVO_i*FOR_proj ;
          SiNon ;
            FOR_EVO = FOR_EVO + (EVO_i * FOR_proj) ;
          FinSi ;
        FIN It ;

        F_Hist = EXTR FOR_EVO ORDO ;

        F_Hist2 = (PROG (EXTR F_Hist 1)) et F_Hist;
        F_Hist2 = ENLEVER F_Hist2 (DIMENSION F_Hist2);

        Second = ((1+alpha)*F_Hist) - (alpha*F_Hist2);
    FinSi ;

    Si ( Nb_NL > 0) ;
        FNL_proj = TABLE ;
        UNL_proj = TABLE ;
        TabLisNL = TABLE ;

        REPETER It_NL Nb_NL ;
            FNL_proj.&It_NL = XTY (Pb.Tab_NL.&It_NL.effo) f LFOR L_f ;

            Si ( EXISTE (Pb.Tab_NL.&It_NL) Poi_int ) ;
                UNL_proj.&It_NL = (EXTR f (Pb.Tab_NL.&It_NL.Dir_int)
                  (Pb.Tab_NL.&It_NL.Poi_int)) * (Pb.Tab_NL.&It_NL.fac_int) ;
            SiNon ;
                UNL_proj.&It_NL = XTY (Pb.Tab_NL.&It_NL.ch_depen) f LFOR L_f;
            FinSi ;
            TabLisNL.&It_NL = PROG ;
        Fin It_NL ;
    FinSi ;

    FamiFTot FamiGTot = PR_ConcatenerFami (It_m-1) ;

* Contribution des modes precendents

    TailFami = DIMENSION FamiFTot;

    Si (TailFami > 0);
        REPETER Mod TailFami;
            gk = FamiGTot.&Mod;
            fk = FamiFTot.&Mod;
            f_K_fk = YTMX f fk K;
            f_C_fk = YTMX f fk C;
            f_M_fk = YTMX f fk M;

            Si (&Mod ega 1) ;
                ModsPrec = (f_K_fk * gk.u) + (f_C_fk * gk.v) + (f_M_fk * gk.w) ;
            SiNon ;
                ModsPrec = ModsPrec +
                            (f_K_fk * gk.u) + (f_C_fk * gk.v) + (f_M_fk * gk.w);
            FinSi ;
        Fin Mod;

        Si Bool1;
            Second = Second - ModsPrec;
        SiNon ;
            Second = (-1) * ModsPrec;
        FinSi ;
    FinSi ;

    Si ((NON Bool1) ET (NON (TailFami > 0)));
        Mess 'il n y a ni effort ni deplacements imposes';
        Mess '--------------------------------------------';
        list CHA.1;
    FinSi ;

    g = PROG ;
    gp = PROG ;
    gpp = PROG ;

    REPETER It En_Nb_Re;

      Si (&It ega 1);
        g_t = 0. ;
        gp_t = 0. ;
        gpp_t = 0. ;
        g_pred = 0. ;
        gp_pred = 0. ;
      SiNon ;
        g_pred = g_t + ((1+alpha)*((dt*gp_t) + ((dt**2)*(0.5-beta)*gpp_t)));
        gp_pred = gp_t + ((1+alpha)*dt*(1-gamma)*gpp_t ) ;
      FinSi ;

      SecondT = EXTR Second &It ;


        Si ( Nb_NL > 0) ;

            REPETER It_NL Nb_NL ;
              Val_UNL = g_t  * UNL_proj.&It_NL ;
              Val_VNL = gp_t * UNL_proj.&It_NL ;
              Si (TailFami > 0) ;
                Si ( EXISTE (Pb.Tab_NL.&It_NL) Poi_int ) ;
                    // Eventuellement l evaluation du cote espace pourrait etre fait hors boucle
                    // PR_EvalPGD pourrait etre condenser pour l'appeler une seule fois
                    Prec_U = PR_EvalPGD (Pb.Tab_NL.&It_NL.Dir_int) (Pb.Tab_NL.&It_NL.Poi_int) &It
                            FamiFTot FamiGTot 'U';
                    Prec_V = PR_EvalPGD (Pb.Tab_NL.&It_NL.Dir_int) (Pb.Tab_NL.&It_NL.Poi_int) &It
                            FamiFTot FamiGTot 'V';
                    Val_UNL = Val_UNL + (Prec_U * (Pb.Tab_NL.&It_NL.fac_int) ) ;
                    Val_VNL = Val_VNL + (Prec_V * (Pb.Tab_NL.&It_NL.fac_int) ) ;
                SiNon ;
                    Prec = PR_EvalPGD (Pb.Tab_NL.&It_NL.ch_depen) &It FamiFTot FamiGTot 'U';
                    Prec = PR_EvalPGD (Pb.Tab_NL.&It_NL.ch_depen) &It FamiFTot FamiGTot 'V';
                    Val_UNL = (Val_UNL + Prec_U) ;
                    Val_VNL = (Val_VNL + Prec_V) ;
                FinSi ;
              FinSi ;

                Val_F_NL Bool_Max= PR_Eval_Force_NL (Pb.Tab_NL.&It_NL) 0.5 VRAI Val_UNL Val_VNL ;
                * !!!! Utiliser Bool_max;

                TabLisNL.&It_NL = (TabLisNL.&It_NL) et (PROG Val_F_NL);
                SecondT = SecondT + ((FNL_proj.&It_NL) * Val_F_NL) ;
            Fin It_NL ;

        FinSi ;


      gpp_t_pr = gpp_t;
      gpp_t = (SecondT - ((Prem_g*g_pred)+(Prem_gp*gp_pred)))/Prem_gpp;

      Si (&It neg 1) ;
        g_t = g_t + (dt*gp_t)
                + ((dt**2)*(0.5-beta)*gpp_t_pr)
                + (beta*(dt**2)*gpp_t) ;
        gp_t = gp_t + (dt*(1-gamma)*gpp_t_pr) + (dt*gamma*gpp_t) ;
      FinSi ;

        g =   g   et (PROG g_t  ) ;
        gp =  gp  et (PROG gp_t ) ;
        gpp = gpp et (PROG gpp_t) ;

    Fin It ;

    g_tmps = TABLE;
    g_tmps.u = g;
    g_tmps.v = gp;
    g_tmps.w = gpp;

  RESPRO g_tmps;

  TabEvoNL = TABLE ;
  Si ( Nb_NL > 0) ;
    REPETER It_NL Nb_NL ;
        TabEvoNL.&It_NL = EVOL MANU T Vec_T F(T) (TabLisNL.&It_NL) ;
    Fin It_NL ;
  FinSi ;
  RESPRO TabEvoNL ;

FINPROC;
