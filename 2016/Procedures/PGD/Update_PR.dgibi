AAVZ
PR_Update
DEBPROC PR_Update;


* Maillage necessaire pour creer les objets de calculs
*   Rigidite et Second membre
Si ((VALE 'DIME') > 2) ;
  P_1 = 0. 0. 0. ;
SiNon ;
  P_1 = 0. 0. ;
FinSi ;
MAI1 = MANU POI1 P_1  ;

TaiSys = DIMENSION FamiF.Cal;
Lis1Up = PROG ((TaiSys*3)**2)* 0. ;
Lis1Init = PROG (TaiSys**2)* 0. ;

LISU_ini = MOTS ;
LISF_ini = MOTS ;
REPE BCL1M TaiSys ;
    Num = ((3 * (&BCL1M - 1) ) + 1);
    COU1 = CHAIN 'U' Num ;
    COF1 = CHAIN 'F' Num ;
    LISU_ini = LISU_ini ET (MOTS COU1) ;
    LISF_ini = LISF_ini ET (MOTS COF1) ;
FIN BCL1M ;

Tab_Mat = TABLE;
Tab_Mat.1 = M ;
Tab_Mat.2 = C ;
Tab_Mat.3 = K ;


LISU_tot = MOTS ;
LISF_tot = MOTS ;
REPE BCL1M (TaiSys*3) ;
    COU1 = CHAIN 'U' &BCL1M ;
    COF1 = CHAIN 'F' &BCL1M ;
    LISU_tot = LISU_tot ET (MOTS COU1) ;
    LISF_tot = LISF_tot ET (MOTS COF1) ;
FIN BCL1M ;

Cha_proj = TABLE;
Cha_proj.Ffi = TABLE;
Cha_proj.F_t = TABLE;
Cha_proj.Ff_init = TABLE;

NL_proj = TABLE;
NL_proj.Ffi = TABLE;
NL_proj.Ff_init = TABLE;
NL_proj.Dfi = TABLE;
NL_proj.Eva_Impo = TABLE;

L_F_NL = PROG ;


* Contribution des efforts

    NbCharg = DIMENSION CHA_TOT ;
    Si (NbCharg > 0);

        REPETER It_1 NbCharg ;
            CHA_i = EXTR CHA_TOT CHAR &It_1 ;
            CHP_i = EXTR CHA_i CHAM ;

            EVO_i = EXTR CHA_i EVOL;
            Cha_proj.F_t.&It_1 = EXTR EVO_i ORDO ;
            Lis_Ffi = PROG;
            Lis_Init = PROG;
            REPETER It_2 TaiSys;
                f_i = FamiF.Cal.&It_2;
                FOR_proj = XTY CHP_i f_i LFOR L_f;
                Lis_Init = Lis_Init ET (PROG FOR_proj);
                Lis_Ffi = Lis_Ffi ET (PROG FOR_proj 0 0);
            FIN It_2;
            * Modifier , passer d une liste a un chpoint
            CHP1 = MANU 'CHPO' MAI1 LISF_ini Lis_Init;
            Cha_proj.Ff_init.&It_1 = CHP1;
            CHP1 = MANU 'CHPO' MAI1 LISF_tot Lis_Ffi;
            Cha_proj.Ffi.&It_1 = CHP1;

        FIN It_1 ;
    FinSi ;

* Contribution des modes initiaux et imposes

    FamiFIni FamiGIni = PR_ConcatenerFami 0 ;
    NbModIni = DIMENSION FamiFIni ;

    Si (NbModIni > 0) ;

        LIS_V_1 = MOTS 'fMf' 'fCf' 'fKf';
        LIS_V_2 = MOTS 'g_A' 'g_V' 'g_U';

        Tab_Ini = TABLE ;
        REPETER It_1 NbModIni ;
            Tab_Ini.&It_1 = TABLE ;
            f_ini = FamiFIni.&It_1 ;
            REPETER It_2 TaiSys ;
                Lis_Vec = PROG ;
                f_ligne = FamiF.Cal.&It_2 ;
                REPETER It_3 3 ;
                    Val1 = YTMX f_ini f_ligne Tab_Mat.&It_3 ;
                    Lis_Vec = Lis_Vec ET (PROG Val1) ;
                Fin It_3;
                Tab_Ini.&It_1 .&It_2 =  MANU 'CHPO' MAI1 LIS_V_1 Lis_Vec ;

            FIN It_2;

            Tab_Ini.&It_1.g = FamiGIni.&It_1 ;
        Fin It_1 ;

    FinSi ;

* Contribution Non Lineaire

    Si (Nb_NL > 0) ;

        REPETER It_NL Nb_NL ;

            Lis_Ffi = PROG;
            Lis_Init = PROG;
            Lis_Dfi = PROG ;

            REPETER It_2 TaiSys;
                f_i = FamiF.Cal.&It_2;
                FNL_proj = XTY (Pb.Tab_NL.&It_NL.effo) f_i LFOR L_f ;

                Si ( EXISTE (Pb.Tab_NL.&It_NL) Poi_int ) ;

                    UNL_proj = (EXTR f_i (Pb.Tab_NL.&It_NL.Dir_int)
                                         (Pb.Tab_NL.&It_NL.Poi_int)) * (Pb.Tab_NL.&It_NL.fac_int)  ;
                SiNon ;
                    UNL_proj = XTY (Pb.Tab_NL.&It_NL.ch_depen) f_i LFOR L_f;
                FinSi ;

                Lis_Init = Lis_Init ET (PROG FNL_proj);
                Lis_Ffi = Lis_Ffi ET (PROG FNL_proj 0 0);
                Lis_Dfi = Lis_Dfi ET (PROG UNL_proj);
            FIN It_2;

            Si (NbModIni > 0) ;
                NL_proj.Eva_Impo.&It_NL = TABLE;
                REPETER It_Impo NbModIni ;
                    NL_proj.Eva_Impo.&It_NL.&It_Impo = TABLE;

                    Si ( EXISTE (Pb.Tab_NL.&It_NL) Poi_int ) ;
                        UNL_proj = (EXTR (FamiFIni.&It_Impo) (Pb.Tab_NL.&It_NL.Dir_int)
                                                             (Pb.Tab_NL.&It_NL.Poi_int)) * (Pb.Tab_NL.&It_NL.fac_int) ;
                    SiNon ;
                        UNL_proj = XTY (Pb.Tab_NL.&It_NL.ch_depen) (FamiFIni.&It_Impo) LFOR L_f;
                    FinSi ;

                    NL_proj.Eva_Impo.&It_NL.&It_Impo.u = UNL_proj * (FamiGIni.&It_Impo.u) ;
                    NL_proj.Eva_Impo.&It_NL.&It_Impo.v = UNL_proj * (FamiGIni.&It_Impo.v) ;
                Fin It_Impo ;
            FinSi ;

            CHP1 = MANU 'CHPO' MAI1 LISF_ini Lis_Init;
            NL_proj.Ff_init.&It_NL = CHP1;
            CHP1 = MANU 'CHPO' MAI1 LISF_tot Lis_Ffi;
            NL_proj.Ffi.&It_NL = CHP1;

            CHP1 = MANU 'CHPO' MAI1 LISU_ini Lis_Dfi;
            NL_proj.Dfi.&It_NL = CHP1;

        FIN It_NL ;
    FinSi ;



* Matrice Pij =
* [  fi*K*fj     fi*C*fj     fi*M*fj ;
*   -dt*gamma       1           0    ;
*   -beta*dt^2      0           1   ];

* Matrice des Pij assembles
REPETER It_1 TaiSys;
    REPETER It_2 3;
        Ind_Lign = ((&It_1-1)*3) + (&It_2-1) + 1;
        Si (&It_2 ega 1);
            REPETER It_3 TaiSys;
                f_ligne = FamiF.Cal.&It_1;
                REPETER It_4 3;
                    f_colo = FamiF.Cal.&It_3;
                    ind_List = (Ind_Lign-1)*(TaiSys*3)
                    + ((&It_3-1)*3) + &It_4;
                    Si (&It_4 ega 1);
                        Val1 = YTMX f_colo f_ligne M ;
                        ind_Init = ((&It_1 - 1) *TaiSys)
                        + (&It_3 - 1) + 1 ;
                        REMPLACER Lis1Init ind_Init Val1;
                    FinSi ;
                    Si (&It_4 ega 2);
                        Val1 = YTMX f_colo f_ligne C ;
                    FinSi ;
                    Si (&It_4 ega 3);
                        Val1 = YTMX f_colo f_ligne K ;
                    FinSi ;
                    REMPLACER Lis1Up ind_List Val1;
                FIN It_4;
            FIN It_3;
        FinSi ;
        Si (&It_2 ega 2);
            ind_List = (Ind_Lign-1)*(TaiSys*3) + (Ind_Lign-2) + 1;
            Val1 = (-1)*(dt*gamma);
            REMPLACER Lis1Up ind_List Val1;
            ind_List = ind_List + 1;
            REMPLACER Lis1Up ind_List 1.;
        FinSi ;
        Si (&It_2 ega 3);
            ind_List = (Ind_Lign-1)*(TaiSys*3) + (Ind_Lign-3) + 1;
            Val1 = (-1)*(beta*(dt**2));
            REMPLACER Lis1Up ind_List Val1;
            ind_List = ind_List + 2;
            REMPLACER Lis1Up ind_List 1.;
        FinSi ;

    FIN It_2;
FIN It_1;


PremInit = MANU 'RIGIDITE' 'TYPE' 'RIGIDITE' MAI1 LISU_ini
'DUAL' LISF_ini 'QUEL' Lis1Init ;


PremMemb = MANU 'RIGIDITE' 'TYPE' 'RIGIDITE' MAI1 LISU_tot
'DUAL' LISF_tot 'QUEL' Lis1Up ;

    New_Fami = TABLE;

REPETER It_1 TaiSys;
    New_Fami.&It_1 = TABLE;
FIN It_1;

REPETER It_T En_Nb_Re;

    Si (&It_T ega 1);
        * Assemblage du second membre

        Si (NbCharg > 0);
            SecoMemb = PR_AjoutEffortSecondMembreUpdate 1 (Cha_proj.Ff_init) ;
        FinSi ;

        Si (NbModIni > 0) ;
            CHP1 = PR_AjoutModeInitSecondMembreUpdate VRAI LISF_ini ;
            Si (NbCharg > 0) ;
                SecoMemb = SecoMemb - CHP1 ;
            SiNon ;
                SecoMemb = (-1) * CHP1 ;
            FinSi ;
        FinSi ;

        Si (Nb_NL > 0) ;
            CHP1 F_NL_T = PR_AjoutEffortNonLinSecondMembreUpdate &It_T (NL_proj.Ff_init) ;
            L_F_NL = L_F_NL et (PROG F_NL_T);

            Bool_1 = ( OU (NbCharg > 0) (NbModIni > 0) ) ;
            Si Bool_1 ;
                SecoMemb = SecoMemb + CHP1 ;
            SiNon ;
                SecoMemb = CHP1 ;
            FinSi ;
        FinSi ;

        Vec_GIni = RESO PremInit SecoMemb;

        REPETER It_1 TaiSys;
            mot1 = EXTR LISU_ini &It_1;
            New_Fami.&It_1.w = PROG (EXTR Vec_GIni mot1 P_1);
            New_Fami.&It_1.v = PROG 0;
            New_Fami.&It_1.u = PROG 0;
        FIN It_1;
    SiNon ; // Si (&It_T ega 1);

        Si (NbCharg > 0);
            SecoMemb = PR_AjoutEffortSecondMembreUpdate &It_T (Cha_proj.Ffi) ;
        FinSi ;

        Si (NbModIni > 0) ;
            CHP1 = PR_AjoutModeInitSecondMembreUpdate FAUX LISF_tot ;
            Si (NbCharg > 0) ;
                SecoMemb = SecoMemb - CHP1 ;
            SiNon ;
                SecoMemb = (-1) * CHP1 ;
            FinSi ;
        FinSi ;

        Lis_Seco = PROG;

        REPETER It_1 TaiSys;
            g_W_m1 = EXTR New_Fami.&It_1.w (&It_T - 1);
            g_V_m1 = EXTR New_Fami.&It_1.v (&It_T - 1);
            g_U_m1 = EXTR New_Fami.&It_1.u (&It_T - 1);
            pred_V = (g_V_m1 + ((dt*(1-gamma)) * g_W_m1));
            pred_U = (g_U_m1 + (dt*g_V_m1) + ((dt**2)*(0.5-beta)*g_W_m1));
            Lis_Seco = Lis_Seco ET (PROG 0. pred_V pred_U);
        FIN It_1;

        Seco_2 = MANU 'CHPO' MAI1 LISF_tot Lis_Seco;

        SecoMemb = SecoMemb + Seco_2;

        Si (Nb_NL > 0) ;
            Bool_1 = ( OU (NbCharg > 0) (NbModIni > 0) ) ;
            Si (NON Up_Pt_Fx) ;
                * Evaluation NL
                    CHP_1_U CHP_1_V = PR_EvalFoncTempsPourUpdate (&It_T - 1) ;
                    CHP1 F_NL_T = PR_AjoutEffortNonLinSecondMembreUpdate &It_T (NL_proj.Ffi) CHP_1_U CHP_1_V ;
                    L_F_NL = L_F_NL et (PROG F_NL_T);

                * Resolution lineaire
                    SecoMemb = SecoMemb + CHP1 ;
                    Vec_G_T = RESO PremMemb SecoMemb;
            SiNon ;
                // !!!! Utiliser Bool_max
                CHP_t__U CHP_t__V = PR_EvalFoncTempsPourUpdate (&It_T - 1) ;
                REPETER It_fxNL 0 ;

                // !!!!
                Si (&It_fxNL > 30) ;
                    Mess 'Point fixe Non Lineaire de l Update non convergent' ;
                    list (EXTR ZZZ 4);
                FinSi ;
                        SM_fx = SecoMemb ;
                    * Evaluation NL
                        CHP1 F_NL_T = PR_AjoutEffortNonLinSecondMembreUpdate &It_T (NL_proj.Ffi) CHP_t__U CHP_t__V ;

                    * Resolution lineaire
                        SM_fx = SM_fx + CHP1 ;
                        Si (&It_fxNL < 3) ;
                            Si (&It_fxNL ega 1) ;
                                SM_f0 = SM_fx ;
                            SiNon ;
                                Si ((PR_NormVecGeneral (SM_f0 - SM_fx) LISF_ini) ega 0) ;
                                    L_F_NL = L_F_NL et (PROG F_NL_T);
                                    Mess '-' ;
                                    QUIT It_fxNL ;
                                FinSi ;
                            FinSi ;
                        FinSi ;
                        Vec_G_Fx = RESO PremMemb SM_fx;
                    * Verification de la convergence
                        Si ( &It_fxNL > 1 ) ;
                            CHP_fx_U = PR_ExtrCompoVectGUpdate 'U' Vec_G_Fx ;
                            CHP_fx_V = PR_ExtrCompoVectGUpdate 'V' Vec_G_Fx ;

                            N_0_U = (PR_NormVecGeneral (CHP_fx_U + CHP_t__U) LISU_ini) ;
                            N_0_V = (PR_NormVecGeneral (CHP_fx_V + CHP_t__V) LISU_ini) ;
                            // Verifier V aussi ?
                            dif_u = 0;
                            dif_v = 0;
                            Si ( N_0_U > 0 );
                                dif_u = ( (PR_NormVecGeneral (CHP_fx_U - CHP_t__U) LISU_ini) * 2 ) / N_0_U ;
                            FinSi ;
                            Si ( N_0_V > 0 );
                                dif_V = ( (PR_NormVecGeneral (CHP_fx_V - CHP_t__V) LISU_ini) * 2 ) / N_0_V ;
                            FinSi ;
                            Mess '&It_T' &It_T 'dif_u' dif_u 'dif_v' dif_v ;

                            cri_0 = 1e-6 ;
                            Aff_iter = chaine '-';
                            Bool_U = (OU (dif_u < cri_0) ( N_0_U ega 0 ) ) ;
                            Bool_V = (OU (dif_v < cri_0) ( N_0_V ega 0 ) ) ;
                            Si ( Bool_U ET Bool_V ) ;
                                Vec_G_T = Vec_G_Fx ;
                                L_F_NL = L_F_NL et (PROG F_NL_T);
                                REPETER It_Aff ((&It_fxNL) - 1) ;
                                    Aff_iter = chaine Aff_iter '-';
                                Fin It_Aff ;

                                Mess Aff_iter;
                                QUIT It_fxNL ;
                            FinSi ;
                        FinSi ;
                    * Mis a jour des variables
                        Vec_G_T = Vec_G_Fx ;
                        CHP_t__U  = PR_ExtrCompoVectGUpdate 'U' Vec_G_t  ;
                        CHP_t__V  = PR_ExtrCompoVectGUpdate 'V' Vec_G_t  ;
                Fin It_fxNL ;

            FInSi ;
        SiNon ; // Si (Nb_NL > 0) ;
            Vec_G_T = RESO PremMemb SecoMemb;
        FinSi ;



        REPETER It_1 TaiSys;
            mot1 = EXTR LISU_tot (((&It_1 - 1) * 3) + 1);
            New_Fami.&It_1.w = New_Fami.&It_1.w ET (PROG (EXTR Vec_G_T mot1 P_1));
            mot1 = EXTR LISU_tot (((&It_1 - 1) * 3) + 2);
            New_Fami.&It_1.v = New_Fami.&It_1.v ET (PROG (EXTR Vec_G_T mot1 P_1));
            mot1 = EXTR LISU_tot (((&It_1 - 1) * 3) + 3);
            New_Fami.&It_1.u = New_Fami.&It_1.u ET (PROG (EXTR Vec_G_T mot1 P_1));
        FIN It_1;

    FinSi ;
Fin It_T ;

RESPRO New_Fami;

FINPROC;
