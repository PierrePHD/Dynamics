


    LFOR = MOTS FX FY FZ FR FT MX MY MZ MT Q;
    L_f  = MOTS UX UY UZ UR UT RX RY RZ RT T;


    // Passage du Probleme en variable locales
        Pb Cal_T = PR_CreationProb;

        K = Pb.K_i;
        M = Pb.M_i;
        C = ((1e-4*K) ET (1e4*M)) * 0.1; // !!!! Valeur de l amortissement ici
        CL_TOT = Pb.CL_TOT_i;
        CHA_TOT = Pb.CHA_TOTi;
        U0 = Pb.U0_i;
        V0 = Pb.V0_i;
        D_Imp = Pb.D_Imp_i ;
        P_intere = Pb.P_intere;
        DirPriv = Pb.DirPriv;

        Nb_NL = DIME (Pb.Tab_NL) ;
        Pb.lambda = 0.5;

        dt = Cal_T.dt;
        Ttot = Cal_T.Ttot;

    // Variable du temps
        En_Nb_Re = PR_TailVectTemp dt Ttot;
        Vec_T = PROG 0. PAS dt Ttot ;


    // schema d'integration
        schema = 3 ;
        alpha = 0.0;
        beta = 0.25;
        gamma = 0.5;

    // Options du point fixe
        DirPt_Fx = VRAI;    // Utiliser le Pt Fx pour la resolution non lineaire directe
        Aff_PtFx = FAUX;    // Visualiser dans le terminal les iterations du Pt Fx NL




//-----------------Resolution Directe-----------------\\

        CL_A = CL_TOT;     // Les conditions limites doivent etre en acceleration

        TEMPS ZERO;
        Sol_Dir = PR_ResolutionTtot M C K CL_A CHA_TOT D_Imp
                        alpha beta gamma dt Ttot U0 V0;
        TEMPS;

        // opti donn 5 ;

        // Affichage
            P3 = (PB.geo) POIN PROC ((0.5/2) 0. 0.);
            PR_AffichageDepNoeud Directe P3 DirPriv 'U';


//-----------------Resolution projetee-----------------\\

    // Option general
        // opti donn 5 ;
        NbModPOD = 2 ;

    // Obtention des modes POD avec Matlab
         Lis_ValS Tab_Mod = PR_SVD_Matlab NbModPOD;

    // Pour eviter de generer et effacer les fichiers necessaires au calcul de la SVD
        //  opti sauv FILEPOD ;
        //  SAUV ;
        //  opti rest FILEPOD ;
        //  rest ;

    // Calcul de la base
        Tab_Mod = PR_POD_Orthogonalisation Tab_Mod ;

        Tab_Pts MAI_POD = PR_Mat_Pts NbModPOD ;
        // Maillage necessaire pour creer les matrices du probleme projete

        K_red   = PR_Projeter Tab_Mod K ;
        M_red   = PR_Projeter Tab_Mod M ;
        C_red   = PR_Projeter Tab_Mod C ;
        U0_red  = PR_Projeter Tab_Mod U0 ;
        V0_red  = PR_Projeter Tab_Mod V0 ;
        CHA_red = PR_Projeter Tab_Mod CHA_TOT ;
        CL_A_red = K_red * 0. ; // Pour les modes CA0 il est inutiles de r√©$eappliquer les CL
        D_Imp_re = PR_Projete_DImp D_Imp ;   // Fonction de copie necessaire pour eviter de dupliquer le pointeur
                                                // La necessite d'une baseothogonnale pourrais perturber cette projections

        Sol_POD = PR_ResolutionTtot M_red C_red K_red CL_A_red CHA_red D_Imp_re
                        alpha beta gamma dt Ttot U0_red V0_red;

    // Affichage
        AffMods = LECT 1 PAS 1 NbModPOD;
        AffSolu = LECT 1 PAS 1 NbModPOD;
        ErrDep ErrEner = PR_CalculErreurAffichGlobal 'POD' DirPriv VRAI;
        PR_AffichageDepNoeud POD AffMods AffSolu P3 DirPriv (Pb.lambda) 'U';


//-----------------Resolution PGD-----------------\\

    // Tables des modes
        FamiF = TABLE;
        FamiG = TABLE;
        FamiF.Cal = TABLE;
        FamiG.Cal = TABLE;
        // Creation des modes dep imposes et dep initiaux non nuls
            FamiF.Imp = TABLE;
            FamiG.Imp = TABLE;
            FamiF.Ini = TABLE;
            FamiG.Ini = TABLE;

    // Option de la resolution PGD
        NbModCal = 4;
        OPT0 = TABLE;
        OPT0.Orth = VRAI;
        OPT0.Upda = VRAI;
        //Option du Pt Fx
            PGDPt_Fx = FAUX;
            Up_Pt_Fx = VRAI;
            Pb.lambda = 0.5;

    // Resolution
        TEMPS ZERO;
        PR_ResolutionPGD NbModCal ;
        TEMPS;
        // Fam_FPre = Tab_Mod ;
        // PR_ResolutionPGD NbModCal Fam_FPre ;
        // PR_ResolutionPGD NbModCal Fam_FPre Fam_GPre ;

        opti donn 5 ;

    // Post Traitement
        *OPTI TRAC PSC;

        ErrDep ErrEner = PR_CalculErreurAffichGlobal 'PGD' DirPriv VRAI;
            AffMods = LECT 1 2 3 4;
            AffSolu = LECT 1 2 3 4;
        PR_AffichageDepNoeud PGD AffMods AffSolu P_intere DirPriv (Pb.lambda) 'U';
        PR_AffichageModesEspace AffMods (FamiF.Cal);
