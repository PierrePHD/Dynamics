


    LFOR = MOTS FX FY FZ FR FT MX MY MZ MT ;
    L_f  = MOTS UX UY UZ UR UT RX RY RZ RT ;


    // Passage du Probleme en variable locales
        Pb Cal_T = PR_CreationProb;

        K = Pb.K_i;
        M = Pb.M_i;
        C = ((1e-4*K) ET (1e4*M)) * 0.1; // !!!! Valeur de l amortissement ici
        CL_TOT = Pb.CL_TOT_i;
        CHA_TOT = Pb.CHA_TOTi;
        U0 = Pb.U0_i;
        V0 = Pb.V0_i;
        D_Imp = Pb.D_Imp_i ;
        P_intere = Pb.P_intere;
        DirPriv = Pb.DirPriv;

        Nb_NL = DIME (Pb.Tab_NL) ;
        Pb.lambda = 0.5;

        dt = Cal_T.dt;
        Ttot = Cal_T.Ttot;

    // Variable du temps
        En_Nb_Re = PR_TailVectTemp dt Ttot;
        Vec_T = PROG 0. PAS dt Ttot ;


    // schema d'integration
        schema = 3 ;
        alpha = 0.0;
        beta = 0.25;
        gamma = 0.5;

            // alpha = -0.3;
            // gamma = (1/2) - alpha;
            // beta  = ((1-alpha)**2)/4;

    // Options du point fixe
        DirPt_Fx = VRAI;    // Utiliser le Pt Fx pour la resolution non lineaire directe
        Aff_PtFx = FAUX;    // Visualiser dans le terminal les iterations du Pt Fx NL




    //-----------------Resolution Directe-----------------\\

        CL_A = CL_TOT;     // Les conditions limites doivent etre en acceleration
                                // Sans probleme tant que les condition imposees sont nulles

        // !!!! rendre les modes CA0
            // Possibilite une soustraire le champ de dep connu a chaque pas de temps(Lourd)
            // Possibilite deux Forcer a zero les modes pour les points au depl imposes non nuls
                // Faire REDU aux points concernes et soustraire

        TEMPS ZERO;
        Sol_Dir = PR_ResolutionTtot M C K CL_A CHA_TOT D_Imp
                        alpha beta gamma dt Ttot U0 V0;
        TEMPS;

        opti donn 5 ;

                    // Evo_0 = D_Imp.1 .TabEvo.W ;
                    // DESS Evo_0 ;
                    FamiF = TABLE ;
                    FamiF.Cal = TABLE;
                    FamiF.Imp = TABLE;
                    FamiF.Ini = TABLE;
                    AffMods = LECT ;
                    AffSolu = LECT ;
                    P3 = (PB.geo) POIN PROC ((0.5/2) 0. 0.);
                    PR_AffichageDepNoeud AffMods AffSolu P_intere DirPriv 'U';

        opti donn 5 ;
    // Obtention des modes POD avec Matlab
         NbModPOD = 4 ;
         Lis_ValS Tab_Mod = PR_SVD_Matlab NbModPOD;


         opti sauv FILEPOD ;
         SAUV Tab_Mod ;

        //  opti rest FILEPOD ; // Pour eviter de generer et effacer les fichiers necessaires au calcul de la SVD
        //  rest ;
         opti donn 5 ;

    // Probleme projete

        // // Maillage necessaire pour creer les matrices du probleme projete
        P_POD MAI_POD = PR_Mai_1Pt ;

        // Tab_Mod D_Imp_re = PR_POD_Orthogonalisation Tab_Mod D_Imp;
        Tab_Mod = PR_POD_Orthogonalisation Tab_Mod D_Imp;

        K_red   = PR_Projeter Tab_Mod K ;
        M_red   = PR_Projeter Tab_Mod M ;
        C_red   = PR_Projeter Tab_Mod C ;
        U0_red  = PR_Projeter Tab_Mod U0 ;
        V0_red  = PR_Projeter Tab_Mod V0 ;
        CHA_red = PR_Projeter Tab_Mod CHA_TOT ;

        CL_red = K_red * 0. ; // !!!! hypothese des mode CA0
                                 // CL_red vide

        Sol_POD = PR_ResolutionTtot M_red C_red K_red CL_red CHA_red D_Imp_re
                        alpha beta gamma dt Ttot U0_red V0_red;

        opti donn 5 ;

        //
        // // opti sauv FILEPOD ;
        // // SAUV Sol_POD Tab_Mod ;
        //
        // opti donne 5 ;
        // NbModCal = 4;
        // ErrDep ErrEner = PR_CalculErreurAffichGlobal 'POD' DirPriv VRAI;
        // opti donne 5 ;
        //
        //
        // // Inutile d'imposer les CL si tous les modes sont CA
        // //      SoluComplete CA0 donne modes CA0
        // //      mais avec dep imposes non nuls, il faudra rendre les
        // //      modes CA0 et ajouter des modes de deplacements imposes
        // // Var_1 = EXTR (Pb.CL_TOT_i) 'DIAG' ;
        // // Var_2 = ENLE Var_1 LX ;
        // // Var_3 = MASQ Var_2 'EGAL' 0. ;
        //
        // //CL_TOT = Pb.CL_TOT_i;
        // // P_intere = Pb.P_intere;
        // // DirPriv = Pb.DirPriv;
        // // Nb_NL = DIME (Pb.Tab_NL) ;


    //-----------------Resolution PGD-----------------\\

    // Tables des modes
        FamiF = TABLE;
        FamiG = TABLE;
        FamiF.Cal = TABLE;
        FamiG.Cal = TABLE;

    // Creation des modes dep imposes et dep initiaux non nuls
        FamiF.Imp = TABLE;
        FamiG.Imp = TABLE;
        FamiF.Ini = TABLE;
        FamiG.Ini = TABLE;

    // Affichage
        AffMods = LECT ;
        AffSolu = LECT ;
        PR_AffichageDepNoeud AffMods AffSolu P_intere DirPriv (Pb.lambda);

    // Option de la resolution PGD
        NbModCal = 4;
        OPT0 = TABLE;
        OPT0.Orth = VRAI;
        OPT0.Upda = VRAI;

        //Option du Pt Fx
            PGDPt_Fx = FAUX;
            Up_Pt_Fx = VRAI;
            Pb.lambda = 0.5;

    // Resolution
        TEMPS ZERO;
        PR_ResolutionPGD NbModCal ;
        TEMPS;
        // Fam_FPre = Tab_Mod ;
        // PR_ResolutionPGD NbModCal Fam_FPre ;
        // PR_ResolutionPGD NbModCal Fam_FPre Fam_GPre ;

opti donn 5 ;

    // Post Traitement
        *OPTI TRAC PSC;

            AffMods = LECT 1 2 3 4;
            AffSolu = LECT 1 2 3 4;
        PR_AffichageDepNoeud AffMods AffSolu P_intere DirPriv (Pb.lambda);
        PR_AffichageModesEspace AffMods (FamiF.Cal);
        ErrDep ErrEner = PR_CalculErreurAffichGlobal 'PGD' DirPriv VRAI;

opti donn 5 ;
