$$$$ _RESO_T
DEBPROC _RESO_T M C K CL_A F alpha beta gamma dt U_tm1 V_tm1 A_tm1;
Vp = V_tm1 + ((( 1+alpha )*dt*(1-gamma))*A_tm1);
Up = U_tm1 + (  ( 1+alpha ) * ( (dt*V_tm1)
+ ( ( (dt**2) * (0.5-beta) )  * A_tm1 )
)
);
S = M ET (
( 1. + alpha ) *
( (C*(gamma*dt)) ET (K*(beta*(dt**2))) )
);
S = S ET CL_A;
A_t = RESO S ( F - (C*Vp) - (K*Up) );
V_t =   V_tm1
+ ((dt*(1-gamma))*A_tm1)
+ ((dt*gamma)*A_t);
U_t = U_tm1 + (dt*V_tm1)
+ ((dt**2)*( ((0.5-beta)*A_tm1) + (beta*A_t) ));
RESPRO A_t ;
RESPRO V_t;
RESPRO U_t;
FINPROC;
$$$$ AAAZ
DEBPROC AAAZ M C K CL_A CHA alpha beta gamma dt Ttot U0 V0;
U_t  = U0;
V_t  = V0;
A_t  = U0 * 0;
U_sol = TABLE;
V_sol = TABLE;
A_sol = TABLE;
U_sol.0 = U0;
V_sol.0 = V0;
NbCharg = DIMENSION CHA ;
REPETER It En_Nb_Re;
It_T = &It - 1;
REPETER It2 NbCharg ;
CHA_i = EXTR CHA CHAR &It2 ;
CHP = EXTR CHA_i CHAM ;
EVO = EXTR CHA_i EVOL ;
CHA_ord = EXTR EVO ORDO;
Val = EXTR CHA_ord &It;
Si (&It neg 1);
Val_t_m = EXTR CHA_ord (&It-1);
Val = ((1+alpha)*Val) - (alpha*Val_t_m) ;
FinSi;
Si (&It2 ega 1) ;
FOR = CHP * Val ;
Sinon ;
FOR = FOR + (CHP * Val) ;
FinSi ;
FIN It2 ;
A_t V_t U_t= _RESO_T M C K CL_A FOR alpha beta gamma dt U_t V_t A_t;
BOOL = It_T > 0 ;
SI BOOL;
U_sol.It_T = U_t;
V_sol.It_T = V_t;
FINSI;
A_sol.It_T = A_t;
FIN It;
Solution = TABLE;
Solution.U = U_sol;
Solution.V = V_sol;
Solution.A = A_sol;
RESPRO Solution ;
FINPROC;
$$$$ AAOZ
DEBPROC AAOZ AffMods*ListEnti;
NbMod = DIMENSION FamiF.Cal;
NbMax = MAXI AffMods;
SI (NbMax > NbMod);
Mess 'Il n y a que ' NbMod ' modes';
opti donn 5;
FinSi;
DEF0 = DEFO (Pb.geo) 0 (FamiF.Cal.1);
trac DEF0;
LMot = MOTS 'ROUG' 'BLEU' 'VERT' 'JAUN' 'VIOL' 'TURQ';
REPETER It (DIMENSION AffMods);
col = EXTR LMot &It;
NumMod = EXTR AffMods &It;
Si (&It ega 1) ;
DEFA = (DEF0 ET (DEFO Pb.geo FamiF.Cal.NumMod col));
Trac DEFA;
Sinon ;
DEFA = (DEFA ET (DEFO Pb.geo FamiF.Cal.NumMod col));
TRAC DEFA;
FinSi ;
Fin It;
*trac DEFA;
FINPROC;
$$$$ AAUZ
DEBPROC AAUZ NbMod*Entier;
LisMotFa = MOTS 'IMP' 'INI' 'CAL';
NumeCoup = 0;
FamiFTot = TABLE;
FamiGTot = TABLE;
REPETER Catego (DIME LisMotFa);
Categori = EXTR LisMotFa &Catego;
NbModCat =(DIME FamiF.Categori);
SI (NbModCat > 0);
SI (neg Categori 'CAL');
REPETER ItCoupl NbModCat;
NumeCoup = NumeCoup + 1;
FamiFTot.NumeCoup = FamiF.Categori.&ItCoupl;
FamiGTot.NumeCoup = FamiG.Categori.&ItCoupl;
FIN ItCoupl;
SINON;
* Si NbMod > NbModCat !!!!!!!!!!!!!!!!!!
SI (NbMod > 0);
REPETER ItCoupl NbModCat;
NumeCoup = NumeCoup + 1;
FamiFTot.NumeCoup = FamiF.Categori.&ItCoupl;
FamiGTot.NumeCoup = FamiG.Categori.&ItCoupl;
FIN ItCoupl;
FINSI;
FINSI;
FINSI;
FIN Catego;
RESPRO FamiFTot;
RESPRO FamiGTot;
FINPROC;
$$$$ AAHZ
DEBPROC AAHZ f1 g1 f2 g2;
* Norme L2
* uKu + uCv + uMa
Res1 Res2 = AAIZ;
* Approximation
*Res1 Res2 = AAJZ;
epsilon = 1e-10 ;
BOOL = (Res2/Res1) < epsilon ;
*BOOL = ((Res1 < epsilon) et (Res2 < epsilon)) ;
RESPRO BOOL ;
FINPROC;
$$$$ AAIZ
DEBPROC AAIZ ;
* Equation dans LaTeX
* si K C et M non symetriques recalculer f2*.*f1
f1Kf1 = XTMX f1 K;
f1Kf2 = YTMX f1 f2 K;
f2Kf2 = XTMX f2 K;
f1Cf1 = XTMX f1 C;
f1Cf2 = YTMX f1 f2 C;
f2Cf2 = XTMX f2 C;
f1Mf1 = XTMX f1 M;
f1Mf2 = YTMX f1 f2 M;
f2Mf2 = XTMX f2 M;
g1_g1 = AADZ g1.u g1.u dt ;
g1_g2 = AADZ g1.u g2.u dt ;
g2_g2 = AADZ g2.u g2.u dt ;
g1_g1p = AADZ g1.u g1.v dt ;
g1_g2p = AADZ g1.u g2.v dt ;
g1p_g2 = AADZ g1.v g2.u dt ;
g2_g2p = AADZ g2.u g2.v dt ;
g1_g1pp = AADZ g1.u g1.w dt ;
g1_g2pp = AADZ g1.u g2.w dt ;
g1pp_g2 = AADZ g1.w g2.u dt ;
g2_g2pp = AADZ g2.u g2.w dt ;
Res2 = ((g1_g1*f1Kf1) - (2*(g1_g2)*f1Kf2)) + (g2_g2*f2Kf2)
+ ((g1_g1p *f1Cf1) -((g1_g2p +g1p_g2 )*f1Cf2) ) + (g2_g2p *f2Cf2)
+ ((g1_g1pp*f1Mf1) -((g1_g2pp+g1pp_g2)*f1Mf2) ) + (g2_g2pp*f2Mf2) ;
Res1 = (g1_g1*f1Kf1) + (g1_g1p *f1Cf1) + (g1_g1pp*f1Mf1) ;
RESPRO Res1;
RESPRO Res2;
FINPROC;
$$$$ AAJZ
DEBPROC AAJZ ;
lg = DIMENSION g1.u;
g1_fin = EXTR g1.u lg;
g2_fin = EXTR g2.u lg;
Val = g1_fin / g2_fin ;
*Val_sign = Sign Val;
f1Kf1 = XTMX f1 K;
f12 = f1 - (f2*Val) ;
f12Kf12 = XTMX f12 K;
Res1 = f12Kf12/f1Kf1;
g12 =  g1.u - (g2.u*Val);
g1_g1   = AADZ g1.u g1.u  dt ;
g12_g12 = AADZ g12 g12    dt ;
Res2 = g12_g12/g1_g1;
RESPRO Res1;
RESPRO Res2;
FINPROC;
$$$$ AADZ
DEBPROC AADZ g1*Listreel g2*listreel dt/flottant Vec_LocT/listreel;
Long1=DIMENSION g1;
Long2=DIMENSION g2;
Bool = Long1 NEG Long2;
SI Bool;
Mess 'Produit de fonctions de differentes longueurs';
Mess 'taille g1:' Long1 '   taille g2:' Long2;
opti donn 5;
* Couper le programme
list (EXTR kk 7);
FINSI;
g1_p = ENLEVER g1 1;
g1_m = ENLEVER g1 (DIMENSION g1);
g2_p = ENLEVER g2 1;
g2_m = ENLEVER g2 (DIMENSION g2);
Bool = EXISTE Vec_LocT;
Si Bool;
Vec_LT_p = ENLEVER Vec_LocT 1;
Vec_LT_m = ENLEVER Vec_LocT (DIMENSION Vec_LocT);
dt = Vec_LT_p - Vec_LT_m;
FinSi;
L_a = (g1_p-g1_m)/dt;
L_e = (g2_p-g2_m)/dt;
*  Int_list =  ( ((dt**3)/3) * (a*e) )
*                +( ((dt**2)/2) * ((a*g2_m)+(e*g1_m)) )
*                +(   dt        * g2_m * g1_m ) ;
* L operateur SOMME va integrer et donc multiplier par dt chaque
*   intervale.
Int_list =  ( ((dt**2)/3) * (L_a*L_e) )
+( (dt/2) * ((L_a*g2_m)+(L_e*g1_m)) )
+( g2_m * g1_m ) ;
Si Bool ;
Int_EVO = EVOL MANU (ENLEVER Vec_LocT (DIMENSION Vec_LocT))  Int_list ;
Int_b = (EXTR (SOMME Int_EVO) 1)
+( (  ( (EXTR Int_list 1) * (EXTR dt 1) )
+ ( (EXTR Int_list (DIMENSION Int_list)) *
(EXTR dt (DIMENSION dt))   )
)/2) ;
SiNon;
Int_EVO = EVOL MANU (ENLEVER Vec_T (DIMENSION Vec_T))  Int_list ;
Int_b = (EXTR (SOMME Int_EVO) 1)
+ (( (EXTR Int_list 1)
+(EXTR Int_list (DIMENSION Int_list))
)*(dt/2));
FinSi;
RESPRO Int_b;
FINPROC;
$$$$ AASZ
DEBPROC AASZ f_espa;
Nor_Esp = (AATZ f_espa f_espa)**0.5;
RESPRO Nor_Esp;
FINPROC;
$$$$ AAQZ
DEBPROC AAQZ ;
Mess 'Verification de l orthogonalite';
FamiFTot FamiGTot = AAUZ (DIMENSION FamiF.Cal ) ;
REPETER It_m (DIMENSION FamiFTot );
REPETER It2_m (DIMENSION FamiFTot );
Pro_f = AATZ FamiFTot.&It_m FamiFTot.&It2_m;
Mess 'Mode ' &It_m ' et ' &It2_m ' : ' Pro_f;
FIN It2_m;
FIN It_m;
Mess 'Gramm-Shmidt';
NorOrigi = AASZ f_espa;
REPETER It_m (DIMENSION FamiF.Cal );
Pro_f = AATZ f_espa FamiF.Cal.&It_m;
NumMod = (DIMENSION FamiF.Cal ) + 1 ;
Mess 'Mode ' &It_m ' et ' NumMod ' : ' Pro_f;
FamiG.Cal.&It_m.u = FamiG.Cal.&It_m.u + (g_tmps.u * Pro_f);
FamiG.Cal.&It_m.v = FamiG.Cal.&It_m.v + (g_tmps.v * Pro_f);
FamiG.Cal.&It_m.w = FamiG.Cal.&It_m.w + (g_tmps.w * Pro_f);
f_espa = f_espa - (FamiF.Cal.&It_m * Pro_f);
NorInter = (AASZ f_espa);
Mess 'NORME = ' NorInter;
FIN It_m;
RESPRO f_espa ;
RESPRO FamiG ;
FINPROC;
$$$$ AALZ
DEBPROC AALZ It_m*Entier;
Sol = TABLE ;
U_sol = TABLE;
V_sol = TABLE;
A_sol = TABLE;
FamiFTot FamiGTot = AAUZ It_m ;
REPETER It2 It_m;
REPETER It En_Nb_Re;
It_T = &It - 1;
Si (&It2 ega 1) ;
U_sol.It_T = FamiFTot.&It2 * (EXTR FamiGTot.&It2.u &It) ;
V_sol.It_T = FamiFTot.&It2 * (EXTR FamiGTot.&It2.v &It) ;
A_sol.It_T = FamiFTot.&It2 * (EXTR FamiGTot.&It2.w &It) ;
Sinon ;
U_sol.It_T = U_sol.It_T + (FamiFTot.&It2 * (EXTR FamiGTot.&It2.u &It)) ;
V_sol.It_T = V_sol.It_T + (FamiFTot.&It2 * (EXTR FamiGTot.&It2.v &It)) ;
A_sol.It_T = A_sol.It_T + (FamiFTot.&It2 * (EXTR FamiGTot.&It2.w &It)) ;
FinSi ;
Fin It;
FIN It2;
Sol.U = U_sol;
Sol.V = V_sol;
Sol.A = A_sol;
RESPRO Sol;
FINPROC;
$$$$ AAFZ
DEBPROC AAFZ M C K CL_A Ttot schema CHA dt It_m ;
g_init = TABLE;
g_init.w = PROG En_Nb_Re * 1. ;
g_init.v = PROG 0. PAS dt Ttot ;
g_init.u = ((g_init.v)**2) /2 ;
g_tmps = g_init;
*gev_ = TABLE;
*fev_ = TABLE;
REPETER It 30;
Mess '  ' &It;
f_espa = AABZ M C K CL_A CHA dt g_tmps It_m ;
Nor_f = AASZ f_espa;
f_espa = f_espa/Nor_f ;
*fev_.&It = f_espa ;
g_tmps = AAEZ M C K Ttot schema CHA dt f_espa It_m ;
*gev_.&It = g_tmps ;
BOOL = &It > 1 ;
SI BOOL;
BoolConv = AAHZ f_espa g_tmps f_prec g_prec;
SI BoolConv;
QUIT It;
FINSI;
FINSI;
f_prec = f_espa;
g_prec = g_tmps;
Fin It ;
Mess '___';
RESPRO f_espa ;
RESPRO g_tmps ;
FINPROC;
$$$$ AABZ
DEBPROC AABZ M C K CL_A CHA dt g It_m ;
Int1 = AADZ g.u g.u dt ;
Int2 = AADZ g.v g.u dt ;
Int3 = AADZ g.w g.u dt ;
Premier = (Int1*K) et (Int2*C) et (Int3*M);
* Contribution des efforts
NbCharg = DIMENSION CHA ;
REPETER It NbCharg ;
CHA_i = EXTR CHA CHAR &It ;
CHP = EXTR CHA_i CHAM ;
EVO = EXTR CHA_i EVOL ;
CH_ord = EXTR EVO ORDO ;
CH_abs = EXTR EVO ABSC ;
Int = AADZ CH_ord g.u CH_abs ;
Si (&It ega 1) ;
Second = (CHP*Int) ;
Sinon ;
Second = Second + (CHP*Int) ;
FinSi ;
FIN It ;
* La somme sur les modes precedents
FamiFTot FamiGTot = AAUZ (It_m-1) ;
Bool = (DIMENSION FamiFTot) > 0;
Si Bool;
TailFami = DIMENSION FamiFTot;
REPETER Mod TailFami;
gk = FamiGTot.&Mod;
fk = FamiFTot.&Mod;
g_gk   = AADZ g.u gk.u dt ;
g_gkp  = AADZ g.u gk.v dt ;
g_gkpp = AADZ g.u gk.w dt ;
Si (&Mod ega 1) ;
Som1 = g_gk   * fk;
Som2 = g_gkp  * fk;
Som3 = g_gkpp * fk;
Sinon ;
Som1 = Som1 + (g_gk   * fk);
Som2 = Som2 + (g_gkp  * fk);
Som3 = Som3 + (g_gkpp * fk);
FinSi ;
Fin Mod;
Second = Second - ( (K*Som1) + (C*Som2) + (M*Som3) ) ;
FinSi;
* Contribution des deplacements imposes
* A FAIRE !!!!!!!!!!!!
* Resolution
Premier = Premier ET CL_A;
f = RESO Premier Second;
RESPRO f;
FINPROC;
$$$$ AAEZ
DEBPROC AAEZ M C K Ttot schema CHA dt f It_m ;
* Creer un procedure pour le schema
alpha = 0.;
beta = 1./4;
gamma = 1./2;
* Cette partie ne pourra plus etre hors de la boucle en non lineaire
Prem_g = XTMX f_espa K ;
Prem_gp = XTMX f_espa C ;
Prem_gpp = XTMX f_espa M ;
g = PROG ;
gp = PROG ;
gpp = PROG ;
NbCharg = DIMENSION CHA ;
REPETER It NbCharg ;
CHA_i = EXTR CHA CHAR &It ;
CHP = EXTR CHA_i CHAM ;
LFOR = MOTS FX FY FZ FR FT MX MY MZ MT ;
L_f = MOTS UX UY UZ UR UT RX RY RZ RT ;
FOR_proj = XTY CHP f LFOR L_f;
EVO = EXTR CHA_i EVOL ;
Si (&It ega 1) ;
FOR_EVO = EVO*FOR_proj ;
Sinon ;
FOR_EVO = FOR_EVO + (EVO * FOR_proj) ;
FinSi ;
FIN It ;
* Verifier que l evolution final amene a Ttot avec En_Nb_Re composantes
F_Hist = EXTR FOR_EVO ORDO ;
F_Hist2 = (PROG (EXTR F_Hist 1)) et F_Hist;
F_Hist2 = ENLEVER F_Hist2 (DIMENSION F_Hist2);
Second = ((1+alpha)*F_Hist) - (alpha*F_Hist2);
FamiFTot FamiGTot = AAUZ (It_m-1) ;
Bool = (DIMENSION FamiFTot) > 0;
Si Bool;
TailFami = DIMENSION FamiFTot;
REPETER Mod TailFami;
gk = FamiGTot.&Mod;
fk = FamiFTot.&Mod;
f_K_fk = YTMX f fk K;
f_C_fk = YTMX f fk C;
f_M_fk = YTMX f fk M;
Si (&Mod ega 1) ;
ModsPrec = (f_K_fk * gk.u) + (f_C_fk * gk.v) + (f_M_fk * gk.w) ;
Sinon ;
ModsPrec = ModsPrec +
(f_K_fk * gk.u) + (f_C_fk * gk.v) + (f_M_fk * gk.w);
FinSi ;
Fin Mod;
FinSi;
* Contribution des modes precendents
Si (It_m > 1);
Second = Second - ModsPrec;
FinSi;
REPETER It En_Nb_Re;
Si (&It ega 1);
g_t = 0. ;
gp_t = 0. ;
gpp_t = 0. ;
g_pred = 0. ;
gp_pred = 0. ;
SiNon;
g_pred = g_t + ((1+alpha)*((dt*gp_t) + ((dt**2)*(0.5-beta)*gpp_t)));
gp_pred = gp_t + ((1+alpha)*dt*(1-gamma)*gpp_t ) ;
FinSi;
SecondT = EXTR Second &It ;
gpp_t_pr = gpp_t;
gpp_t = (SecondT - ((Prem_g*g_pred)+(Prem_gp*gp_pred)))/Prem_gpp;
Si (&It neg 1) ;
g_t = g_t + (dt*gp_t)
+ ((dt**2)*(0.5-beta)*gpp_t_pr)
+ (beta*(dt**2)*gpp_t) ;
gp_t = gp_t + (dt*(1-gamma)*gpp_t_pr) + (dt*gamma*gpp_t) ;
FinSi;
g =   g   et (PROG g_t  ) ;
gp =  gp  et (PROG gp_t ) ;
gpp = gpp et (PROG gpp_t) ;
Fin It ;
g_tmps = TABLE;
g_tmps.u = g;
g_tmps.v = gp;
g_tmps.w = gpp;
RESPRO g_tmps;
FINPROC;
$$$$ AATZ
DEBPROC AATZ f1_espa f2_espa;
* Norme L2
L_f = MOTS UX UY UZ UR UT RX RY RZ RT ;
Pro_Sca = XTY f1_espa f2_espa L_f L_f;
RESPRO Pro_Sca;
* Possibilite d utiliser X.K.Y ou X.M.Y
FINPROC;
$$$$ AARZ
DEBPROC AARZ NbModCal*Entier;
REPETER It_m NbModCal;
REPETER Ort -1;
f_espa g_tmps = AAFZ M C K CL_A Ttot schema CHA_TOT dt &It_m;
BOOL = (OPT0.Orth) ET (&It_m > 1);
SI BOOL;
f_espa FamiG = AAQZ;
Mess 'f_espaNEW = ' (AASZ f_espa) ;
SI ((AASZ f_espa) < 0.1);
Mess 'Mode rejete';
SINON;
f_espa = f_espa/(AASZ f_espa);
QUITTER Ort;
FINSI;
SINON;
QUITTER Ort;
FINSI;
Fin Ort;
FamiF.Cal.&It_m = f_espa;
FamiG.Cal.&It_m = g_tmps;
Fin It_m;
FINPROC;
$$$$ AAVZ
DEBPROC AAVZ;
*
*
*!!!!!!! Ajouter conribution des modes 'IMP' 'INI' 'CAL';
*
*
* Maillage necessaire pour creer les objets de calculs
*   Rigidite et Second membre
SI ((VALE 'DIME') > 2) ;
P_1 = 0. 0. 0. ;
SINON ;
P_1 = 0. 0. ;
FINSI ;
MAI1 = MANU POI1 P_1  ;
TaiSys = DIMENSION FamiF.Cal;
Lis1Up = PROG ((TaiSys*3)**2)* 0. ;
Lis1Init = PROG (TaiSys**2)* 0. ;
LISU_ini = MOTS ;
LISF_ini = MOTS ;
REPE BCL1M TaiSys ;
Num = ((3 * (&BCL1M - 1) ) + 1);
COU1 = CHAIN 'U' Num ;
COF1 = CHAIN 'F' Num ;
LISU_ini = LISU_ini ET (MOTS COU1) ;
LISF_ini = LISF_ini ET (MOTS COF1) ;
FIN BCL1M ;
LISU_tot = MOTS ;
LISF_tot = MOTS ;
REPE BCL1M (TaiSys*3) ;
COU1 = CHAIN 'U' &BCL1M ;
COF1 = CHAIN 'F' &BCL1M ;
LISU_tot = LISU_tot ET (MOTS COU1) ;
LISF_tot = LISF_tot ET (MOTS COF1) ;
FIN BCL1M ;
Cha_proj = TABLE;
Cha_proj.Ffi = TABLE;
Cha_proj.F_t = TABLE;
Cha_proj.Ff_init = TABLE;
* Projection F . f_espa_i
NbCharg = DIMENSION CHA_TOT ;
SI (NbCharg > 0);
LFOR = MOTS FX FY FZ FR FT MX MY MZ MT ;
L_f = MOTS UX UY UZ UR UT RX RY RZ RT ;
REPETER It_1 NbCharg ;
CHA_i = EXTR CHA_TOT CHAR &It_1 ;
CHP = EXTR CHA_i CHAM ;
EVO_1 = EXTR CHA_i EVOL;
Cha_proj.F_t.&It_1 = EXTR EVO_1 ORDO ;
Lis_Ffi = PROG;
Lis_Init = PROG;
REPETER It_2 TaiSys;
f_i = FamiF.Cal.&It_2;
FOR_proj = XTY CHP f_i LFOR L_f;
Lis_Init = Lis_Init ET (PROG FOR_proj);
Lis_Ffi = Lis_Ffi ET (PROG FOR_proj 0 0);
FIN It_2;
* Modifier , passer d une liste a un chpoint
CHP1 = MANU 'CHPO' MAI1 LISF_ini Lis_Init;
Cha_proj.Ff_init.&It_1 = CHP1;
CHP1 = MANU 'CHPO' MAI1 LISF_tot Lis_Ffi;
Cha_proj.Ffi.&It_1 = CHP1;
FIN It_1 ;
FINSI;
RESPRO Cha_proj;
* Matrice Pij =
* [  fi*K*fj     fi*C*fj     fi*M*fj ;
*   -dt*gamma       1           0    ;
*   -beta*dt^2      0           1   ];
* Matrice des Pij assembles
REPETER It_1 TaiSys;
REPETER It_2 3;
Ind_Lign = ((&It_1-1)*3) + (&It_2-1) + 1;
SI (&It_2 ega 1);
REPETER It_3 TaiSys;
f_ligne = FamiF.Cal.&It_1;
REPETER It_4 3;
f_colo = FamiF.Cal.&It_3;
ind_List = (Ind_Lign-1)*(TaiSys*3)
+ ((&It_3-1)*3) + &It_4;
SI (&It_4 ega 1);
Val1 = YTMX f_colo f_ligne M ;
FINSI;
SI (&It_4 ega 2);
Val1 = YTMX f_colo f_ligne C ;
FINSI;
SI (&It_4 ega 3);
Val1 = YTMX f_colo f_ligne K ;
ind_Init = ((&It_1 - 1) *TaiSys)
+ (&It_3 - 1) + 1 ;
REMPLACER Lis1Init ind_Init Val1;
FINSI;
REMPLACER Lis1Up ind_List Val1;
FIN It_4;
FIN It_3;
FINSI;
SI (&It_2 ega 2);
ind_List = (Ind_Lign-1)*(TaiSys*3) + (Ind_Lign-2) + 1;
Val1 = (-1)*(dt*gamma);
REMPLACER Lis1Up ind_List Val1;
ind_List = ind_List + 1;
REMPLACER Lis1Up ind_List 1.;
FINSI;
SI (&It_2 ega 3);
ind_List = (Ind_Lign-1)*(TaiSys*3) + (Ind_Lign-3) + 1;
Val1 = (-1)*(beta*(dt**2));
REMPLACER Lis1Up ind_List Val1;
ind_List = ind_List + 2;
REMPLACER Lis1Up ind_List 1.;
FINSI;
FIN It_2;
FIN It_1;
PremInit = MANU 'RIGIDITE' 'TYPE' 'RIGIDITE' MAI1 LISU_ini
'DUAL' LISF_ini 'QUEL' Lis1Init ;
PremMemb = MANU 'RIGIDITE' 'TYPE' 'RIGIDITE' MAI1 LISU_tot
'DUAL' LISF_tot 'QUEL' Lis1Up ;
RESPRO PremInit;
RESPRO PremMemb;
RESPRO P_1;
New_Fami = TABLE;
REPETER It_1 TaiSys;
New_Fami.&It_1 = TABLE;
FIN It_1;
REPETER It_T En_Nb_Re;
Si (&It_T ega 1);
* Assemblage du second membre
REPETER It_1 (DIMENSION Cha_proj.F_t);
Si (&It_1 ega 1);
SecoMemb = (EXTR (Cha_proj.F_t.&It_1) 1) * (Cha_proj.Ff_init.&It_1);
SINON;
SecoMemb = SecoMemb +
((EXTR (Cha_proj.F_t.&It_1) 1) * (Cha_proj.Ff_init.&It_1)) ;
FINSI;
FIN It_1;
Vec_GIni = RESO PremInit SecoMemb;
REPETER It_1 TaiSys;
mot1 = EXTR LISU_ini &It_1;
New_Fami.&It_1.w = PROG (EXTR Vec_GIni mot1 P_1);
New_Fami.&It_1.v = PROG 0;
New_Fami.&It_1.u = PROG 0;
FIN It_1;
SiNon;
* Creer fonction pour eviter la repetition de l'assemblage
REPETER It_1 (DIMENSION Cha_proj.F_t);
Si (&It_1 ega 1);
SecoMemb = (EXTR (Cha_proj.F_t.&It_1) &It_T) * (Cha_proj.Ffi.&It_1);
SINON;
SecoMemb = SecoMemb +
((EXTR (Cha_proj.F_t.&It_1) &It_T) * (Cha_proj.Ffi.&It_1)) ;
FINSI;
FIN It_1;
Lis_Seco = PROG;
REPETER It_1 TaiSys;
g_W_m1 = EXTR New_Fami.&It_1.w (&It_T - 1);
g_V_m1 = EXTR New_Fami.&It_1.v (&It_T - 1);
g_U_m1 = EXTR New_Fami.&It_1.u (&It_T - 1);
pred_V = (g_V_m1 + ((dt*(1-gamma)) * g_W_m1));
pred_U = (g_U_m1 + (dt*g_V_m1) + ((dt**2)*(0.5-beta)*g_W_m1));
Lis_Seco = Lis_Seco ET (PROG 0. pred_V pred_U);
*REMPLACER SecoMemb (((&It_1 - 1) *3) + 2) pred_V;
*REMPLACER SecoMemb (((&It_1 - 1) *3) + 3) pred_U;
FIN It_1;
Seco_2 = MANU 'CHPO' MAI1 LISF_tot Lis_Seco;
SecoMemb = SecoMemb + Seco_2;
Vec_G_T = RESO PremMemb SecoMemb;
REPETER It_1 TaiSys;
mot1 = EXTR LISU_tot (((&It_1 - 1) * 3) + 1);
New_Fami.&It_1.w = New_Fami.&It_1.w ET (PROG (EXTR Vec_G_T mot1 P_1));
mot1 = EXTR LISU_tot (((&It_1 - 1) * 3) + 2);
New_Fami.&It_1.v = New_Fami.&It_1.v ET (PROG (EXTR Vec_G_T mot1 P_1));
mot1 = EXTR LISU_tot (((&It_1 - 1) * 3) + 3);
New_Fami.&It_1.u = New_Fami.&It_1.u ET (PROG (EXTR Vec_G_T mot1 P_1));
FIN It_1;
FINSI;
Fin It_T ;
RESPRO New_Fami;
FINPROC;
$$$$ AAKZ
DEBPROC AAKZ AffMods*ListEnti AffSolu*ListEnti P*Point Coord;
NbMod = DIMENSION FamiF.Cal;
NbMax = MAXI (AffMods et AffSolu);
SI (NbMax > NbMod);
Mess 'Il n y a que ' NbMod ' modes';
opti donn 5;
FinSi;
FamiFTot FamiGTot = AAUZ NbMax ;
Sol_dir = PROG;
REPE It En_Nb_Re;
It_T = &It - 1;
Sol_dir = Sol_dir ET (PROG (EXTR Solu1.U.It_T Coord P));
FIN It;
Sol_k = TABLE;
Mod_k = TABLE;
REPETER It2 NbMax;
Sol_PGD = PROG;
Val = EXTR FamiFTot.&It2 Coord P;
REPE It En_Nb_Re;
It_T = &It - 1;
Sol_PGD = Sol_PGD ET (PROG (Val* (EXTR FamiGTot.&It2.u &It) ));
FIN It;
Sol_k.&It2 = Sol_PGD;
Mod_k.&It2 = Sol_PGD;
SI (&It2 > 1);
REPETER It3 (&It2-1);
Sol_k.&It2 = Sol_k.&It2 + Mod_k.&It3 ;
Fin It3;
FinSi;
FIN It2;
Evol_dir = EVOL MANU Vec_T Sol_dir ;
Evo_k = TABLE;
LMot = MOTS 'ROUG' 'BLEU' 'VERT' 'JAUN' 'VIOL' 'TURQ';
* Affichage des Solutions
Si ( (DIMENSION AffSolu) > 0);
REPETER It (MINI ((DIMENSION AffSolu) et 6));
col = EXTR LMot &It;
num = (EXTR AffSolu &It)
+ (DIME FamiF.Ini)
+ (DIME FamiF.Imp);
Evo_k.&It = EVOL col MANU Vec_T Sol_k.num .u;
Si (&It ega 1) ;
Tot = Evol_dir et Evo_k.&It;
Sinon ;
Tot = Tot et Evo_k.&It;
FinSi ;
Fin It;
DESS Tot ;
*XBOR 0. 5e-4 YBOR -3e-6 7e-6;
FinSi;
* Affichage des modes
Si ( (DIMENSION AffMods) > 0);
REPETER It (MINI ((DIMENSION AffMods) et 6));
col = EXTR LMot &It;
num = EXTR AffMods &It;
Evo_k.&It = EVOL col MANU Vec_T Mod_k.num .u;
Si (&It ega 1) ;
Tot = Evol_dir et Evo_k.&It;
Sinon ;
Tot = Tot et Evo_k.&It;
FinSi ;
Fin It;
DESS Tot;
Finsi;
FINPROC;
$$$$ AAPZ
DEBPROC AAPZ Coord/MOT BOOL2/LOGIQUE;
BOOL1 = EXISTE Coord;
BOOL3 = OU (NON BOOL1) (EXISTE BOOL2);
ErrDepMo = PROG;
ErrParMo = PROG;
EneTot = PROG;
REPETER It_m NbModCal;
rec_sol = AALZ &It_m;
Err = AAMZ Solu1.u rec_sol.u;
ErrMax = PROG;
ErrTotM = -0.1;
REPE IT_T En_Nb_Re;
in_T = &IT_T - 1;
SI BOOL1;
ErrTotM = MAXI ( PROG
(MAXI (ABS ((EXCO Coord Err.in_T))))
ErrTotM
);
SoluT = EXCO Coord Solu1.u.in_T;
Si (&IT_T ega 1) ;
Max_Dep = MAXI SoluT;
Min_Dep = MINI SoluT;
SINON;
Max_Dep = MAXI ( PROG (MAXI SoluT) Max_Dep );
Min_Dep = MINI ( PROG (MINI SoluT) Min_Dep );
FINSI;
FINSI;
SI BOOL3;
ErrMaxT = XTMX Err.in_T K;
ErrMax = ErrMax et ErrMaxT;
Si (&It_m ega 1) ;
EneTotT = XTMX Solu1.u.in_T K;
EneTot = EneTot et EneTotT;
FINSI;
FINSI;
FIN IT_T;
SI BOOL1;
ErrDepMo = ErrDepMo ET ErrTotM;
FINSI;
SI BOOL3;
ErrTotEV = EVOL MANU T Vec_T Errr ErrMax ;
EneTotEV = EVOL MANU T Vec_T Errr EneTot ;
ErrParMo = ErrParMo ET (SOMM ErrTotEV);
FINSI;
FIN It_m;
SI (NbModCal ega 1);
LMod = PROG 1;
SINON;
LMod = (PROG 1 PAS 1 NbModCal);
FINSI;
SI BOOL1;
Ampli = Max_Dep - Min_Dep;
Mess 'Max_Dep' Max_Dep 'Min_Dep' Min_Dep 'Ampli' Ampli;
ErrDepMo = ErrDepMo / Ampli;
Mess 'Erreur Relative en Deplacement sur ' Coord
' en fonction du nombre de mode';
list (EVOL MANU Mode LMod Erreur ErrDepMo);
RESPRO ErrDepMo;
FINSI;
SI BOOL3;
ErrParMo = ErrParMo / (EXTR (SOMM EneTotEV) 1) ;
Mess 'Erreur Energetique en fonction du nombre de mode';
list (EVOL MANU Mode LMod Erreur ErrParMo);
RESPRO ErrParMo;
FINSI;
FINPROC;
$$$$ AAMZ
DEBPROC AAMZ Sol_1 Sol_2 ;
Sol = TABLE ;
REPETER It En_Nb_Re ;
It_T = &It - 1 ;
Sol.It_T = Sol_1.It_T - Sol_2.It_T ;
Fin It ;
RESPRO Sol ;
FINPROC;
$$$$ AANZ
DEBPROC AANZ;
OPTI DIME 3 ;
OPTI ELEM SEG2 ;
*
OPTI 'ACQU' 'Maillage_Treillis.txt' ;
*
* Noeuds
*
NOE1 = TABLE ;
REPE BCL1N 45 ;
ACQU XY1*LISTREEL 4 ;
LIST XY1 ;
ACQU XY2*LISTREEL 2 ;
LIST XY2 ;
X1 = (EXTR 2 XY1)/1000. ;
Y1 = (EXTR 3 XY1)/1000. ;
Z1 = (EXTR 2 XY2)/1000. ;
NOE1 . &BCL1N = X1 Y1 Z1 ;
FIN BCL1N ;
*
* Elements barre
*
BAR1 = TABLE ;
N1E = 90 ;
REPE BCL1E N1E ;
ACQU XY1*LISTENTI 4 ;
N1 = EXTR 3 XY1 ;
N2 = EXTR 4 XY1 ;
BAR1 . &BCL1E = DROI 10 NOE1 . N1 NOE1 . N2 ;
SI (&BCL1E EGA 1) ;
MAI1 = BAR1 . &BCL1E ;
SINON ;
MAI1 = MAI1 ET BAR1 . &BCL1E ;
FINSI ;
FIN BCL1E ;
*
* Trac√© du maillage
*
TRAC MAI1 ;
*
* Proprietes des poutres
*
D1E = 0.030  ;
D1I = 0.027  ;
IY1 = PI*((D1E**4)-(D1I**4))/64 ;
IZ1 = PI*((D1E**4)-(D1I**4))/64 ;
I01 = PI*((D1E**4)-(D1I**4))/32 ;
S1 =  PI*((D1E**2)-(D1I**2))/4  ;
YOU1 = 7.E10 ;
RHO1 = 2700. ;
*
REPE BCL1E N1E ;
*
MOD1 = MODE BAR1 . &BCL1E MECANIQUE ELASTIQUE POUTRE ;
MAT1 = MATE MOD1 'YOUNG' YOU1 'NU' 0.3 'RHO' RHO1 ;
CAR1 = CARA MOD1 SECT S1 'INRY' IY1 'INRZ' IY1 'TORS' I01 ;
RIG1 = RIGI MOD1 (MAT1 ET CAR1);
MAS1 = MASS MOD1 (MAT1 ET CAR1);
SI (&BCL1E EGA 1) ;
MAS1TOT = MAS1 ;
RIG1TOT = RIG1 ;
SINON ;
RIG1TOT = RIG1TOT ET RIG1 ;
MAS1TOT = MAS1TOT ET MAS1 ;
FINSI ;
*
FIN BCL1E ;
*
* Conditions aux limites
* Front - Rear - Left - Right
CL1FR = NOE1 . 20 ;
CL1FL = NOE1 . 25 ;
CL1RR = NOE1 . 30 ;
CL1RL = NOE1 . 35 ;
*
K1 = 1.E6 ;
BLO1 = (BLOQ CL1FR UY UX UZ RX RY RZ) ET
(BLOQ CL1FL UY UX UZ RX RY RZ) ET
(BLOQ CL1RR  UY UX UZ RX RY RZ) ET
(BLOQ CL1RL UY UX UZ RX RY RZ) ;
Pb = TABLE;
V0001 = TABLE;
*---------------------DONNEES---------------------*
*Unites SI
AMP1 = -100.0 ;
*-------MATRICES DE RIGIDITE ET DE MASSE----------*
Pb.K = RIG1TOT;
Pb.M = MAS1TOT ;
Pb.Mob = MOD1;
*--------------CONDITIONS LIMITES-----------------*
Pb.CL_TOT= BLO1 ;
P3 = MAI1 POIN PROC (250. 500. 950.);
P4 = MAI1 POIN PROC (250. -500. 950.);
Pb.geo = MAI1;
*--------------Parametres de calcul---------------*
V0001.dt = 8e-5;
V0001.Ttot = 4e-2;
Pb.T_period = 2e-2 ;
En_Nb_Re = AAGZ V0001.dt V0001.Ttot;
Vec_T = PROG 0. PAS V0001.dt V0001.Ttot ;
*------------EVOLUTION TEMPORELLE-----------------*
LIS1 = (PROG sinu (1/Pb.T_period) PHAS 270 Vec_T) ;
LIS1 = LIS1 + (PROG En_Nb_Re*1.);
EVT1 = EVOL MANU T Vec_T G(T) LIS1 ;
EVT2 = EVOL MANU T Vec_T G(T) (Vec_T*2) ;
*-----------------CHARGEMENT----------------------*
FOR1 = FORCE FZ AMP1 P3 ;
FOR2 = FORCE FZ AMP1 P4 ;
CHA1 = CHAR FORC FOR1 EVT1 ;
CHA2 = CHAR FORC FOR2 EVT1 ;
Pb.CHA_TOT = CHA1 et CHA2;
dep0 = MANU CHPO MAI1 3 'UX' 0. 'UY' 0. 'UZ' 0. NATURE 'DIFF';
Pb.U0  = dep0;
Pb.V0  = dep0;
Pb.P_intere = P3;
RESPRO Pb;
RESPRO V0001;
FINPROC;
$$$$ AAGZ
DEBPROC AAGZ dt Ttot;
Fl_Nb_Pa = Ttot/dt + 0.1;
Fl_Nb_Re = Fl_Nb_Pa + 1.;
En_Nb_Re = ENTI Fl_Nb_Re ;
RESPRO En_Nb_Re;
FINPROC;
$$$$
