$$$$ ABIZ
DEBPROC ABIZ For_HHT*CHPOINT;
A_HHT_t = RESO S ( For_HHT - (C*Vp) - (K*Up) );
V_HHT_t =   V_tm1
+ ((dt*(1-gamma))*A_tm1)
+ ((dt*gamma)*A_HHT_t);
U_HHT_t = U_tm1 + (dt*V_tm1)
+ ((dt**2)*( ((0.5-beta)*A_tm1) + (beta*A_HHT_t) ));
RESPRO A_HHT_t ;
RESPRO V_HHT_t ;
RESPRO U_HHT_t ;
FINPROC;
$$$$ _RESO_T
DEBPROC _RESO_T M C K CL_A F alpha beta gamma dt U_tm1 V_tm1 A_tm1;
Vp = V_tm1 + ((( 1+alpha )*dt*(1-gamma))*A_tm1);
Up = U_tm1 + (  ( 1+alpha ) * ( (dt*V_tm1)
+ ( ( (dt**2) * (0.5-beta) )  * A_tm1 )
)
);
S = M ET (
( 1. + alpha ) *
( (C*(gamma*dt)) ET (K*(beta*(dt**2))) )
);
S = S ET CL_A;
* Non Lineaire
Si ( Nb_NL > 0) ;
A_t V_t U_t = ABPZ F 10 'Dir' DirPt_Fx ;
SiNon ; 
A_t V_t U_t = ABIZ F ;
FinSi ;
RESPRO A_t ;
RESPRO V_t;
RESPRO U_t;
FINPROC;
$$$$ AAAZ
DEBPROC AAAZ M C K CL_A CHA alpha beta gamma dt Ttot U0 V0;
U_t  = U0;
V_t  = V0;
A_t  = U0 * 0;
U_sol = TABLE;
V_sol = TABLE;
A_sol = TABLE;
U_sol.0 = U0;
V_sol.0 = V0;
NbCharg = DIMENSION CHA ;
REPETER It En_Nb_Re;
It_T = &It - 1;
Si (NbCharg > 0);
REPETER It2 NbCharg ;
CHA_i = EXTR CHA CHAR &It2 ;
CHP_i = EXTR CHA_i CHAM ;
EVO_i = EXTR CHA_i EVOL ;
CHA_ord = EXTR EVO_i ORDO;
Val = EXTR CHA_ord &It;
Si (&It neg 1);
Val_t_m = EXTR CHA_ord (&It-1);
Val = ((1+alpha)*Val) - (alpha*Val_t_m) ;
FinSi ;
Si (&It2 ega 1) ;
FOR_Imp = CHP_i * Val ;
SiNon ;
FOR_Imp = FOR_Imp + (CHP_i * Val) ;
FinSi ;
FIN It2 ;
SiNon ;
FOR_Imp = U0 * 0;
FinSi ;
A_t V_t U_t= _RESO_T M C K CL_A FOR_Imp alpha beta gamma dt U_t V_t A_t;
Si (It_T > 0);
U_sol.It_T = U_t;
V_sol.It_T = V_t;
FinSi ;
A_sol.It_T = A_t;
FIN It;
Solution = TABLE;
Solution.U = U_sol;
Solution.V = V_sol;
Solution.W = A_sol;
RESPRO Solution ;
FINPROC;
$$$$ AANZ
DEBPROC AANZ;
OPTI DIME 3 ;
OPTI ELEM SEG2 ;
*
OPTI 'ACQU' 'Maillage_Treillis.txt' ;
*
* Noeuds
*
NOE1 = TABLE ;
REPE BCL1N 45 ;
ACQU XY1*LISTREEL 4 ;
* LIST XY1 ;
ACQU XY2*LISTREEL 2 ;
* LIST XY2 ;
X1 = (EXTR 2 XY1)/1000. ;
Y1 = (EXTR 3 XY1)/1000. ;
Z1 = (EXTR 2 XY2)/1000. ;
NOE1 . &BCL1N = X1 Y1 Z1 ;
FIN BCL1N ;
*
* Elements barre
*
BAR1 = TABLE ;
N1E = 90 ;
REPE BCL1E N1E ;
ACQU XY1*LISTENTI 4 ;
N1 = EXTR 3 XY1 ;
N2 = EXTR 4 XY1 ;
BAR1 . &BCL1E = DROI 10 NOE1 . N1 NOE1 . N2 ;
Si (&BCL1E EGA 1) ;
MAI1 = BAR1 . &BCL1E ;
SiNon ;
MAI1 = MAI1 ET BAR1 . &BCL1E ;
FinSi ;
FIN BCL1E ;
*
* Trac√© du maillage
*
TRAC MAI1 ;
*
* Proprietes des poutres
*
D1E = 0.030  ;
D1I = 0.027  ;
IY1 = PI*((D1E**4)-(D1I**4))/64 ;
IZ1 = PI*((D1E**4)-(D1I**4))/64 ;
I01 = PI*((D1E**4)-(D1I**4))/32 ;
S1 =  PI*((D1E**2)-(D1I**2))/4  ;
YOU1 = 7.E10 ;
RHO1 = 2700. ;
*
REPE BCL1E N1E ;
*
MOD1 = MODE BAR1 . &BCL1E MECANIQUE ELASTIQUE POUTRE ;
MAT1 = MATE MOD1 'YOUNG' YOU1 'NU' 0.3 'RHO' RHO1 ;
CAR1 = CARA MOD1 SECT S1 'INRY' IY1 'INRZ' IY1 'TORS' I01 ;
RIG1 = RIGI MOD1 (MAT1 ET CAR1);
MAS1 = MASS MOD1 (MAT1 ET CAR1);
Si (&BCL1E EGA 1) ;
MAS1TOT = MAS1 ;
RIG1TOT = RIG1 ;
SiNon ;
RIG1TOT = RIG1TOT ET RIG1 ;
MAS1TOT = MAS1TOT ET MAS1 ;
FinSi ;
*
FIN BCL1E ;
*
* Conditions aux limites
* Front - Rear - Left - Right
CL1FR = NOE1 . 20 ;
CL1FL = NOE1 . 25 ;
CL1RR = NOE1 . 30 ;
CL1RL = NOE1 . 35 ;
*
K1 = 1.E6 ;
BLO1 = (BLOQ CL1FR UY UX UZ RX RY RZ) ET
(BLOQ CL1FL UY UX UZ RX RY RZ) ET
(BLOQ CL1RR  UY UX UZ RX RY RZ) ET
(BLOQ CL1RL UY UX UZ RX RY RZ) ;
Pb = TABLE;
Cal_T = TABLE;
Pb.DirPriv = 'UZ';
*---------------------DONNEES---------------------*
*Unites SI
AMP1 = -100.0 ;
*-------MATRICES DE RIGIDITE ET DE MASSE----------*
Pb.K = RIG1TOT;
Pb.M = MAS1TOT ;
Pb.Mob = MOD1;
*--------------CONDITIONS LIMITES-----------------*
Pb.CL_TOT= BLO1 ;
P3 = MAI1 POIN PROC (250. 500. 950.);
P4 = MAI1 POIN PROC (250. -500. 950.);
Pb.geo = MAI1;
*--------------Parametres de calcul---------------*
Cal_T.dt = 8e-5;
Cal_T.Ttot = 4e-2;
Pb.T_period = 2e-2 ;
En_Nb_Re = AAGZ Cal_T.dt Cal_T.Ttot;
Vec_T = PROG 0. PAS Cal_T.dt Cal_T.Ttot ;
*------------EVOLUTION TEMPORELLE-----------------*
LIS1 = (PROG sinu (1/Pb.T_period) PHAS 270 Vec_T) ;
LIS1 = LIS1 + (PROG En_Nb_Re*1.);
EVT1 = EVOL MANU T Vec_T G(T) LIS1 ;
EVT2 = EVOL MANU T Vec_T G(T) (Vec_T*2) ;
*-----------------CHARGEMENT----------------------*
FOR1 = FORCE FZ AMP1 P3 ;
FOR2 = FORCE FZ AMP1 P4 ;
CHA1 = CHAR FORC FOR1 EVT1 ;
CHA2 = CHAR FORC FOR2 EVT1 ;
Pb.CHA_TOT = CHA1 et CHA2;
Pb.Tab_NL = TABLE;
dep0 = MANU CHPO MAI1 3 'UX' 0. 'UY' 0. 'UZ' 0. NATURE 'DIFF';
Pb.U0  = dep0;
Pb.V0  = dep0;
Pb.P_intere = P3;
RESPRO Pb;
RESPRO Cal_T;
FINPROC;
$$$$ AASZ
DEBPROC AASZ f_espa Mat_0/RIGIDITE;
Si (EXISTE Mat_0) ;
* X.K.Y (YTMX  X Y M)
Nor_Esp = (AATZ f_espa f_espa Mat_0)**0.5;
SiNon ;
* Norme L2
Nor_Esp = (AATZ f_espa f_espa)**0.5;
FinSi ;
RESPRO Nor_Esp;
FINPROC;
$$$$ ABMZ
DEBPROC ABMZ Val_0/FLOTTANT Vec_1/CHPOINT LIS_mot/LISTMOTS ;
* Norme L2
Si (EXISTE Vec_1) ;
Nor_1 = XTY Vec_1 Vec_1 LIS_mot LIS_mot;
SiNon ;
Nor_1 = ABS Val_0 ;
FinSi ;
RESPRO Nor_1;
FINPROC;
$$$$ AATZ
DEBPROC AATZ f1_espa f2_espa Mat_1/RIGIDITE;
Si (EXISTE Mat_1) ;
* X.K.Y (YTMX  X Y M)
Pro_Sca = YTMX f1_espa f2_espa Mat_1;
SiNon ;
* Norme L2
Pro_Sca = XTY f1_espa f2_espa L_f L_f;
FinSi ;
RESPRO Pro_Sca ;
FINPROC;
$$$$ AAGZ
DEBPROC AAGZ dt Ttot;
Fl_Nb_Pa = Ttot/dt + 0.1;
Fl_Nb_Re = Fl_Nb_Pa + 1.;
En_Nb_Re = ENTI Fl_Nb_Re ;
RESPRO En_Nb_Re;
FINPROC;
$$$$ ABAZ
DEBPROC ABAZ Val_Bute*TABLE U*FLOTTANT lambda*FLOTTANT Max/LOGIQUE;
Raideur = (Val_Bute.Raideur) ;
Jeu = (Val_Bute.Jeu) ;
DeltaJeu = (Val_Bute.DeltaJeu) ;
Si (EXISTE Max) ;
U = Jeu + DeltaJeu ;
FinSi;
Max_Veri = FAUX ;
*Si ( NON (EXISTE lambda) ) ;
*    lambda = 0.1 ;
*FinSi ;
Si (U < Jeu);
F_B = 0 ;
SiNon ;
Val_Max = Jeu + (lambda * DeltaJeu) ;
Si (U > Val_Max );
Max_Veri = VRAI ;
U = Val_Max ;
FinSi;
F_B = ABBZ ;
FinSi ;
RESPRO F_B ;
RESPRO Max_Veri ;
FINPROC;
$$$$ ABCZ
DEBPROC ABCZ NL_Tab*TABLE Var_NL*LISTREEL ;
Effort = PROG ;
Bool_Tot = FAUX;
REPE It En_Nb_Re;
Val_U = (EXTR Var_NL &It) ;
Si ( (NL_Tab.typ) ega 1 ) ;
Val Bool_Max= ABAZ (NL_Tab.Butee) Val_U (Pb.lambda);
Si Bool_Max ;
Bool_Tot = VRAI;
FinSi ;
FinSi ;
Effort = Effort ET (PROG Val);
FIN It;
Val_max Bool_Max= ABAZ (NL_Tab.Butee) Val_U Pb.lambda VRAI;
Mess ' ValMaxAtteinte =' (MAXI ( ABS (Effort) ) ) ;
Mess ' ValMaxLambda   =' Val_max ' Pb.lambda = ' (Pb.lambda);
Si Bool_Tot ;
Mess ' Valeur MAX Atteinte ' ;
FinSi ;
RESPRO Effort ;
FINPROC;
$$$$ ABHZ
DEBPROC ABHZ NL_Tab*TABLE lambda*FLOTTANT Val_Scal*LOGIQUE
Val_U/FLOTTANT Val_V/FLOTTANT CHP_U/CHPOINT CHP_V/CHPOINT ;
Si Val_Scal ;
U_NL = Val_U ;
V_NL = Val_V ;
SiNon ;
Si (EXISTE NL_Tab.Poi_int) ;
U_NL = ( EXTR CHP_U (NL_Tab.Dir_int) (NL_Tab.Poi_int) ) *
(NL_Tab.fac_int);
V_NL = ( EXTR CHP_V (NL_Tab.Dir_int) (NL_Tab.Poi_int) ) *
(NL_Tab.fac_int);
SiNon ;
U_NL = XTY (NL_Tab.ch_depen) CHP_U LFOR L_f;
V_NL = XTY (NL_Tab.ch_depen) CHP_V LFOR L_f;
FinSi ;
FinSi ;
Si ( (NL_Tab.typ) ega 1 ) ;
Val_Effo Bool_Max= ABAZ (NL_Tab.Butee) U_NL lambda ;
FinSi ;
Si Val_Scal ;
Effort = Val_Effo ;
SiNon ;
Effort = Val_Effo * NL_Tab.effo ;
FinSi ;
RESPRO Effort ;
RESPRO Bool_Max ;
FINPROC;
$$$$ ABOZ
DEBPROC ABOZ Enr_Val*LOGIQUE VarU  VarV  SM_0 ;
Bool_Tot = FAUX;
REPETER It_NL Nb_NL ;
Si (Dir) ;
SM_NL Bool_M= ABHZ (Pb.Tab_NL.&It_NL) (Pb.lambda) FAUX V_U_NL V_V_NL ;
FinSi ;
Si (PGD) ;
Val_F_NL Bool_M= ABHZ (Pb.Tab_NL.&It_NL) (Pb.lambda)
VRAI V_U_NL V_V_NL ;
SM_NL = ((FNL_proj.&It_NL) * Val_F_NL) ;
FinSi ;
Si (Upd) ;
SM_NL Val_F_NL Bool_M = ABGZ &It_NL &It_T (NL_proj.Ffi) 
V_U_NL V_V_NL ;
FinSi ;
Si (( OU PGD Upd) ET Enr_Val) ;
TabLisNL.&It_NL = (TabLisNL.&It_NL) et (PROG Val_F_NL);
FinSi ;
Si Bool_M ;
Bool_Tot = VRAI ;
FinSi ;
SM_0 = SM_0 + SM_NL ;
Fin It_NL ;
RESPRO SM_0 ;
RESPRO Bool_Tot ;
FINPROC;
$$$$ ABBZ
DEBPROC ABBZ ;
F_Rep = (((-1) * Raideur * (DeltaJeu**2))
/ ((U - Jeu) - DeltaJeu))
+( Raideur * ((Jeu - DeltaJeu) - U))  ;
RESPRO F_Rep ;
FINPROC;
$$$$ ABPZ
DEBPROC ABPZ SM_Lin it_Temps*ENTIER Tri*MOT B_Pt_Fx;
Dir = FAUX;
PGD = FAUX;
Upd = FAUX;
Si (EGA Tri 'Dir') ;
Dir = VRAI ;
FinSi ;
Si (EGA Tri 'PGD') ;
PGD = VRAI ;
FinSi ;
Si (EGA Tri 'Upd') ;
Upd = VRAI ;
FinSi ;
Si (PGD) ;
* Evaluation des g (t) pour les modes precedents
Prec_U = TABLE;
Prec_V = TABLE;
REPETER It_NL Nb_NL ;
Si (TailFami > 0) ;
Si ( EXISTE (Pb.Tab_NL.&It_NL) Poi_int ) ;
Prec_U.&It_NL = (ABFZ FamiFTot FamiGTot ('U')
(Pb.Tab_NL.&It_NL.Dir_int) (Pb.Tab_NL.&It_NL.Poi_int) it_Temps) *
(Pb.Tab_NL.&It_NL.fac_int)    ;
Prec_V.&It_NL = (ABFZ FamiFTot FamiGTot ('V')
(Pb.Tab_NL.&It_NL.Dir_int) (Pb.Tab_NL.&It_NL.Poi_int) it_Temps) *
(Pb.Tab_NL.&It_NL.fac_int)    ;
SiNon ;
Prec_U.&It_NL = ABFZ FamiFTot FamiGTot ('U')
(Pb.Tab_NL.&It_NL.ch_depen) it_Temps ;
Prec_V.&It_NL = ABFZ FamiFTot FamiGTot ('V')
(Pb.Tab_NL.&It_NL.ch_depen) it_Temps ;
FinSi ;
FinSi ;
Fin It_NL ;
FinSi ;
* Evaluation implicite
Si (OU (NON B_Pt_Fx) (it_Temps ega 1));   
* Evaluation NL
* La dependance (t-1)
Si (Dir) ;
V_U_NL = U_tm1 ;
V_V_NL = V_tm1 ;
FinSi ;
Si (PGD) ;
V_U_NL V_V_NL = ABNZ ;
FinSi ;
Si (Upd) ;
V_U_NL V_V_NL = ABKZ (it_Temps - 1) ;
FinSi ;
* L effort
Enr_Val = VRAI;
SM_Fx Bool_nul = ABOZ Enr_Val V_U_NL V_V_NL SM_Lin;
* Resolution lineaire
Si (Dir) ;
A_t V_t U_t = ABIZ SM_Fx ;
FinSi ;
Si (PGD) ;
gpp_t gp_t g_t = ABJZ SM_Fx it_Temps;
FinSi ;
Si (Upd) ;
Vec_G_T = RESO PremMemb SM_Fx;
FinSi ;
* Point fixe
SiNon ;
* Evaluation (t-1)
Si (Dir) ;
U_t = U_tm1 ;
V_t = V_tm1 ;
FinSi ;
Si (Upd) ;
CHP_t__U CHP_t__V = ABKZ (it_Temps - 1) ;
FinSi ;
REPETER It_fxNL 0 ;
* Initialisation
Si (&It_fxNL > 30) ;
Mess 'Point fixe Non Lineaire de l Update non convergent' ;
list (EXTR ZZZ 4);
FinSi ;
* Evaluation NL
* La dependance
Si (Dir) ;
V_U_NL = U_t ;
V_V_NL = V_t ;
FinSi ;
Si (PGD) ;
V_U_NL V_V_NL = ABNZ ;
FinSi ;
Si (Upd) ;
V_U_NL = CHP_t__U ;
V_V_NL = CHP_t__V ;
FinSi ;
* L effort
Enr_Val = FAUX;
SM_Fx Bool_Max = ABOZ Enr_Val V_U_NL V_V_NL SM_Lin ; 
* Sortie Rapide du Pt Fixe si NL n evolue pas
Si (&It_fxNL < 3) ;
Si (&It_fxNL ega 1) ;
SM_f0 = SM_Fx ; 
SiNon ;
Si ( OU Dir PGD) ;
LISF_Tri = LFOR ;
FinSi ;
Si (Upd) ;
LISF_Tri = LISF_ini ;
FinSi ;
Si ((ABMZ (SM_f0 - SM_fx) LISF_Tri) ega 0) ;
Si Bool_Max ;
Pb.lambda = 1 - ((1 - (Pb.lambda))/ 2 ) ;
Bool_Max = FAUX;
Enr_Val = FAUX ;
SM_Fx Bool_Max = ABOZ Enr_Val V_U_NL V_V_NL SM_Lin;
Mess 'Val control atteinte dans Sortie Rapide du point fixe NL';
Mess 'nouveau lambda=' (Pb.lambda) ;
SiNon ;
* Conserver F_NL
Si (OU PGD Upd) ;
Enr_Val = VRAI;
SM_Fx Bool_Max = ABOZ Enr_Val V_U_NL V_V_NL SM_Lin ; 
FinSi ;
* Affichage
Si Aff_PtFx ;
Mess '-' ;
FinSi ;
QUIT It_fxNL ;
FinSi ;
FinSi ;
FinSi ;
FinSi ;
* Resolution lineaire
Si (Dir) ;
A_t V_fx U_fx = ABIZ SM_Fx ;
FinSi ;
Si (PGD) ;
gpp_t gp_fx_t g_fx_t = ABJZ SM_Fx it_Temps;
FinSi ;
Si (Upd) ;
Vec_G_Fx = RESO PremMemb SM_Fx;
FinSi ;
* Verification de la convergence
Si ( &It_fxNL > 1 ) ;
* Evolution en une iteration du Point fixe
Si (Dir) ;
N_0_U = (AASZ (U_fx + U_t) K) ;
N_0_V = (AASZ (V_fx + V_t) C) ; 
N_diff_U = (AASZ (U_fx - U_t) K) ;
N_diff_V = (AASZ (V_fx - V_t) C) ; 
FinSi ;
Si (PGD) ;
N_0_U = ABS (g_fx_t + g_t) ;
N_0_V = ABS (gp_fx_t + gp_t) ;
N_diff_U = ABS (g_fx_t - g_t) ;
N_diff_V = ABS (gp_fx_t - gp_t) ;
FinSi ;
Si (Upd) ;
CHP_fx_U = ABLZ 'U' Vec_G_Fx ;
CHP_fx_V = ABLZ 'V' Vec_G_Fx ;
N_0_U = (ABMZ (CHP_fx_U + CHP_t__U) LISU_ini) ;
N_0_V = (ABMZ (CHP_fx_V + CHP_t__V) LISU_ini) ;
N_diff_U = (ABMZ (CHP_fx_U - CHP_t__U) LISU_ini) ;
N_diff_V = (ABMZ (CHP_fx_V - CHP_t__V) LISU_ini) ;
FinSi ;
dif_u = 0;
dif_v = 0;
Si ( N_0_U > 0 );
dif_u = ( N_diff_U * 2 ) / N_0_U ;
FinSi ;
Si ( N_0_V > 0 );
dif_V = ( N_diff_V * 2 ) / N_0_V ;
FinSi ;
Si (PGD) ;
cri_0 = 1e-6 ;
SiNon ;
cri_0 = 1e-4 ;
FinSi ;
Aff_iter = chaine '-';
Bool_U = (dif_u < cri_0) ;
Bool_V = (dif_v < cri_0) ;
Si ( Bool_U ET Bool_V ) ;
Si Bool_Max ;
Pb.lambda = 1 - ((1 - (Pb.lambda))/ 2 ) ;
Mess 'Val control atteinte a l iteration ' &It_fxNL ' F=' F_NL_T;
Mess 'lambda=' (Pb.lambda) ;
SiNon ;
* Sortir derniere valeur
Si (Dir) ;
U_t = U_fx ;
V_t = V_fx ;
FinSi ;
Si (PGD) ;
g_t = g_fx_t  ;
gp_t = gp_fx_t ;
FinSi ;
Si (Upd) ;
Vec_G_t = Vec_G_Fx;
FinSi ;
* Conserver F_NL 
Si (OU PGD Upd) ;
Enr_Val = VRAI;
SM_Fx Bool_Max = ABOZ Enr_Val V_U_NL V_V_NL SM_Lin ; 
FinSi ;
* Affichage
Si Aff_PtFx ;
REPETER It_Aff ((&It_fxNL) - 1) ;
Aff_iter = chaine Aff_iter '-' ;
Fin It_Aff ;
Mess Aff_iter ;
FinSi ;
QUIT It_fxNL ;
FinSi ;
FinSi ;
FinSi ; 
* Mis a jour des variables pour prochaine iteration du Pt Fixe
Si (Dir) ;
U_t = U_fx ;
V_t = V_fx ;
FinSi ;
Si (PGD) ;
g_t = g_fx_t  ;
gp_t = gp_fx_t ;
FinSi ;
Si (Upd) ;
Vec_G_t = Vec_G_Fx;
CHP_t__U  = ABLZ 'U' Vec_G_t  ;
CHP_t__V  = ABLZ 'V' Vec_G_t  ;
FinSi ;
Fin It_fxNL ;
FInSi ; 
Si (Dir) ;
RESPRO A_t ;
RESPRO V_t ;
RESPRO U_t ;
FinSi ;
Si (PGD) ;
RESPRO gpp_t ;
RESPRO  gp_t ;
RESPRO   g_t ;
FinSi ;
Si (Upd) ;
RESPRO Vec_G_T ;
FinSi ;
FINPROC;
$$$$ ABGZ
DEBPROC ABGZ Num_NL*ENTIER It_Temps*ENTIER Prod*TABLE
CHP_U/CHPOINT CHP_V/CHPOINT;
Si ((It_Temps ega 1) ) ;
U_NL_pre = 0;
V_NL_pre = 0;
SiNon ;
U_NL_pre = XTY CHP_U (NL_proj.Dfi.Num_NL) LISU_ini LISU_ini;
V_NL_pre = XTY CHP_V (NL_proj.Dfi.Num_NL) LISU_ini LISU_ini;
FinSi ;
Si (NbModIni > 0) ;
REPETER It_Impo NbModIni ;
U_NL_pre = U_NL_pre +
(EXTR (NL_proj.Eva_Impo.Num_NL.&It_Impo.u) It_Temps) ;
V_NL_pre = V_NL_pre +
(EXTR (NL_proj.Eva_Impo.Num_NL.&It_Impo.v) It_Temps) ;
Fin It_Impo ;
FinSi ;
Val_F_NL Bool_Max = ABHZ (Pb.Tab_NL.Num_NL) (Pb.lambda) VRAI
U_NL_pre V_NL_pre;
SM =        Val_F_NL * (Prod.Num_NL) ;
RESPRO SM ;
RESPRO Val_F_NL ;
RESPRO Bool_Max ;
FINPROC;
$$$$ AAYZ
DEBPROC AAYZ It_T*ENTIER Prod*TABLE;
REPETER It_1 (DIMENSION Cha_proj.F_t);
Si (&It_1 ega 1);
SM = (EXTR (Cha_proj.F_t.&It_1) It_T) * (Prod.&It_1);
SiNon ;
SM = SM +
((EXTR (Cha_proj.F_t.&It_1) It_T) * (Prod.&It_1)) ;
FinSi ;
FIN It_1;
RESPRO SM ;
FINPROC;
$$$$ AAZZ
DEBPROC AAZZ Bool_Ini*LOGIQUE Lis_Comp*LISTMOTS;
REPETER It_1 NbModIni ;
Lis_gIni = PROG ( EXTR Tab_Ini.&It_1.g.w &It_T)
( EXTR Tab_Ini.&It_1.g.v &It_T)
( EXTR Tab_Ini.&It_1.g.u &It_T) ;
CHP2 = MANU 'CHPO' MAI1 LIS_V_2 Lis_gIni ;
Lis_SIni = PROG;
REPETER It_2 TaiSys;
FIni_Fi = Tab_Ini.&It_1 .&It_2 ;
Val1 = XTY FIni_Fi CHP2 LIS_V_1 LIS_V_2;
SI Bool_Ini ;
Lis_SIni = Lis_SIni et (PROG Val1) ;
SiNon ;
Lis_SIni = Lis_SIni et (PROG Val1 0. 0.) ;
FinSi ;
FIN It_2;
CHP2 = MANU 'CHPO' MAI1 Lis_Comp Lis_SIni ;
Fin It_1 ;
RESPRO CHP2;
FINPROC;
$$$$ AAUZ
DEBPROC AAUZ NbMod*Entier;
LisMotFa = MOTS 'IMP' 'INI' 'CAL';
NumeCoup = 0;
FamiFTot = TABLE;
FamiGTot = TABLE;
REPETER Catego (DIME LisMotFa);
Categori = EXTR LisMotFa &Catego;
NbModCat =(DIME FamiF.Categori);
Si (NbModCat > 0);
Si (neg Categori 'CAL');
REPETER ItCoupl NbModCat;
NumeCoup = NumeCoup + 1;
FamiFTot.NumeCoup = FamiF.Categori.&ItCoupl;
FamiGTot.NumeCoup = FamiG.Categori.&ItCoupl;
FIN ItCoupl;
SiNon ;
Si (NbMod > 0);
Si (NbMod > NbModCat);
Mess 'Il n y a que ' NbModCat ' modes, pas ' NbMod;
list FamiF.Categori.NbMod;
FinSi ;
REPETER ItCoupl NbMod;
NumeCoup = NumeCoup + 1;
FamiFTot.NumeCoup = FamiF.Categori.&ItCoupl;
FamiGTot.NumeCoup = FamiG.Categori.&ItCoupl;
FIN ItCoupl;
FinSi ;
FinSi ;
FinSi ;
FIN Catego;
RESPRO FamiFTot;
RESPRO FamiGTot;
FINPROC;
$$$$ AAHZ
DEBPROC AAHZ f1 g1 f2 g2;
* Norme L2
* uKu + uCv + uMa
Res1 Res2 = AAIZ;
* Approximation
*Res1 Res2 = AAJZ;
epsilon = 1e-10 ;
Bool = (Res2/Res1) < epsilon ;
*Bool = ((Res1 < epsilon) et (Res2 < epsilon)) ;
RESPRO Bool ;
FINPROC;
$$$$ AAIZ
DEBPROC AAIZ ;
* Equation dans LaTeX
* Si K C et M non symetriques recalculer f2*.*f1
f1Kf1 = XTMX f1 K;
f1Kf2 = YTMX f1 f2 K;
f2Kf2 = XTMX f2 K;
f1Cf1 = XTMX f1 C;
f1Cf2 = YTMX f1 f2 C;
f2Cf2 = XTMX f2 C;
f1Mf1 = XTMX f1 M;
f1Mf2 = YTMX f1 f2 M;
f2Mf2 = XTMX f2 M;
g1_g1 = AADZ g1.u g1.u dt ;
g1_g2 = AADZ g1.u g2.u dt ;
g2_g2 = AADZ g2.u g2.u dt ;
g1_g1p = AADZ g1.u g1.v dt ;
g1_g2p = AADZ g1.u g2.v dt ;
g1p_g2 = AADZ g1.v g2.u dt ;
g2_g2p = AADZ g2.u g2.v dt ;
g1_g1pp = AADZ g1.u g1.w dt ;
g1_g2pp = AADZ g1.u g2.w dt ;
g1pp_g2 = AADZ g1.w g2.u dt ;
g2_g2pp = AADZ g2.u g2.w dt ;
Res2 = ((g1_g1*f1Kf1) - (2*(g1_g2)*f1Kf2)) + (g2_g2*f2Kf2)
+ ((g1_g1p *f1Cf1) -((g1_g2p +g1p_g2 )*f1Cf2) ) + (g2_g2p *f2Cf2)
+ ((g1_g1pp*f1Mf1) -((g1_g2pp+g1pp_g2)*f1Mf2) ) + (g2_g2pp*f2Mf2) ;
Res1 = (g1_g1*f1Kf1) + (g1_g1p *f1Cf1) + (g1_g1pp*f1Mf1) ;
RESPRO Res1;
RESPRO Res2;
FINPROC;
$$$$ AAJZ
DEBPROC AAJZ ;
lg = DIMENSION g1.u;
g1_fin = EXTR g1.u lg;
g2_fin = EXTR g2.u lg;
Val = g1_fin / g2_fin ;
*Val_sign = Sign Val;
f1Kf1 = XTMX f1 K;
f12 = f1 - (f2*Val) ;
f12Kf12 = XTMX f12 K;
Res1 = f12Kf12/f1Kf1;
g12 =  g1.u - (g2.u*Val);
g1_g1   = AADZ g1.u g1.u  dt ;
g12_g12 = AADZ g12 g12    dt ;
Res2 = g12_g12/g1_g1;
RESPRO Res1;
RESPRO Res2;
FINPROC;
$$$$ ABKZ
DEBPROC ABKZ It_Temps*ENTIER ;
Lis_gu_T = PROG ;
Lis_gv_T = PROG ;
REPETER It_2 TaiSys;
* Evaluation au pas precedent
g_U_m1 = EXTR New_Fami.&It_2 .u It_Temps ;
g_V_m1 = EXTR New_Fami.&It_2 .v It_Temps ;
Lis_gu_T = Lis_gu_T et (PROG g_U_m1) ;
Lis_gv_T = Lis_gv_T et (PROG g_V_m1) ;
FIN It_2;
CHP_1_U = MANU 'CHPO' MAI1 LISU_ini Lis_gu_T;
CHP_1_V = MANU 'CHPO' MAI1 LISU_ini Lis_gv_T;
RESPRO CHP_1_U;
RESPRO CHP_1_V;
FINPROC;
$$$$ ABFZ
DEBPROC ABFZ Grandeur*MOT FamiFEva*TABLE FamiGEva*TABLE
Coord/MOT Pt_local/Point CHP_Prod/CHPOINT Pas_T/ENTIER ;
Bool__Pt = EXISTE Pt_local ;
Bool_Chp = EXISTE CHP_Prod ;
Bool___T = EXISTE Pas_T ;
Bool_PtT = (OU Bool__Pt Bool_Chp) ET Bool___T ;
TailFami = DIMENSION FamiFEva;
Bool_5 = TailFami > 0;
Si (NON Bool_5) ;
Mess 'Il n y a pas de mode a evaluer' ;
list (EXTR ZZZ 4) ;
FinSi ;
REPETER It2 TailFami;
Si Bool_PtT ;
* --- Deplacement du point au temps donne ---
Si Bool__Pt ;
Val = EXTR (FamiFEva.&It2) Coord Pt_local;
SiNon ;
Val = XTY CHP_Prod (FamiFEva.&It2) LFOR L_f ;
FinSi ;
Mod_PGD = Val * (EXTR (FamiGEva.&It2.Grandeur) Pas_T) ;
Si (&It2 > 1);
Sol_PGD = Sol_PGD + Mod_PGD ;
SiNon ;
Sol_PGD = Mod_PGD;
FinSi ;
SiNon ;
* --- Deplacement dans le temps du point ---
Si (OU Bool__Pt Bool_Chp) ;
Si (Bool__Pt) ;
Val = EXTR (FamiFEva.&It2) Coord Pt_local;
SiNon ;
Val = XTY Bool_Chp (FamiFEva.&It2) LFOR L_f ;
FinSi ;
Mod_PGD = Val * (FamiGEva.&It2.Grandeur) ;
Si (&It2 > 1);
Sol_PGD = Sol_PGD + Mod_PGD ;
SiNon ;
Sol_PGD = Mod_PGD;
FinSi ;
FinSi ;
* --- Deplacement du maillage au temps donne ---
Si Bool___T ;
Val = FamiFEva.&It2 ;
Mod_PGD = Val * (EXTR (FamiGEva.&It2.Grandeur) Pas_T) ;
Si (&It2 > 1);
Sol_PGD = Sol_PGD + Mod_PGD ;
SiNon ;
Sol_PGD = Mod_PGD;
FinSi ;
FinSi ;
FinSi;
FIN It2;
RESPRO Sol_PGD ;
FINPROC;
$$$$ ABNZ
DEBPROC ABNZ ;
REPETER It_NL Nb_NL ;
Var_U_NL = g_t  * UNL_proj.&It_NL ;
Var_V_NL = gp_t * UNL_proj.&It_NL ;
Si (TailFami > 0) ;
Var_U_NL = (Var_U_NL + Prec_U.&It_NL) ;
Var_V_NL = (Var_V_NL + Prec_V.&It_NL) ;
FinSi ;
Fin It_NL ;
RESPRO Var_U_NL ;
RESPRO Var_V_NL ;
FINPROC;
$$$$ ABLZ
DEBPROC ABLZ Grandeur*MOT Vec_G*CHPOINT;
Si (EGA Grandeur 'U') ;
Num_Comp = 3 ;
FinSi ;
Si (EGA Grandeur 'V') ;
Num_Comp = 2 ;
FinSi ;
Si (EGA Grandeur 'A') ;
Num_Comp = 1 ;
FinSi ;
Lis_Comp = PROG ;
REPETER It_1 TaiSys ;
mot_1 = EXTR LISU_tot (((&It_1 - 1) * 3) + Num_Comp) ;
Lis_Comp = Lis_Comp ET (PROG (EXTR Vec_G mot_1 P_1)) ;
FIN It_1 ;
Compo = MANU 'CHPO' MAI1 LISU_ini Lis_Comp ;
RESPRO Compo;
FINPROC;
$$$$ AADZ
DEBPROC AADZ g1*Listreel g2*listreel dt/flottant Vec_LocT/listreel;
Long1=DIMENSION g1;
Long2=DIMENSION g2;
Bool = Long1 NEG Long2;
Si Bool;
Mess 'Produit de fonctions de differentes longueurs';
Mess 'taille g1:' Long1 '   taille g2:' Long2;
* Couper le programme
list (EXTR zzz 4);
FinSi ;
g1_p = ENLEVER g1 1;
g1_m = ENLEVER g1 (DIMENSION g1);
g2_p = ENLEVER g2 1;
g2_m = ENLEVER g2 (DIMENSION g2);
Bool = EXISTE Vec_LocT;
Si Bool;
Vec_LT_p = ENLEVER Vec_LocT 1;
Vec_LT_m = ENLEVER Vec_LocT (DIMENSION Vec_LocT);
dt = Vec_LT_p - Vec_LT_m;
FinSi ;
L_a = (g1_p-g1_m)/dt;
L_e = (g2_p-g2_m)/dt;
*  Int_list =  ( ((dt**3)/3) * (a*e) )
*                +( ((dt**2)/2) * ((a*g2_m)+(e*g1_m)) )
*                +(   dt        * g2_m * g1_m ) ;
* L operateur SOMME va integrer et donc multiplier par dt chaque
*   intervale.
Int_list =  ( ((dt**2)/3) * (L_a*L_e) )
+( (dt/2) * ((L_a*g2_m)+(L_e*g1_m)) )
+( g2_m * g1_m ) ;
Si Bool ;
Int_EVO = EVOL MANU (ENLEVER Vec_LocT (DIMENSION Vec_LocT))  Int_list ;
Int_b = (EXTR (SOMME Int_EVO) 1)
+( (  ( (EXTR Int_list 1) * (EXTR dt 1) )
+ ( (EXTR Int_list (DIMENSION Int_list)) *
(EXTR dt (DIMENSION dt))   )
)/2) ;
SiNon ;
Int_EVO = EVOL MANU (ENLEVER Vec_T (DIMENSION Vec_T))  Int_list ;
Int_b = (EXTR (SOMME Int_EVO) 1)
+ (( (EXTR Int_list 1)
+(EXTR Int_list (DIMENSION Int_list))
)*(dt/2));
FinSi ;
RESPRO Int_b;
FINPROC;
$$$$ AAQZ
DEBPROC AAQZ ;
Mess 'Verification de l orthogonalite';
*FamiFTot FamiGTot = AAUZ (DIMENSION FamiF.Cal ) ;
REPETER It_m (DIMENSION FamiF.Cal );
REPETER It2_m (DIMENSION FamiF.Cal );
Pro_f = AATZ (FamiF.Cal.&It_m) (FamiF.Cal.&It2_m) K;
Mess 'Mode ' &It_m ' et ' &It2_m ' : ' Pro_f;
FIN It2_m;
FIN It_m;
Mess 'Gramm-Shmidt';
NorOrigi = AASZ f_espa K;
REPETER It_m (DIMENSION FamiF.Cal );
Pro_f = AATZ f_espa (FamiF.Cal.&It_m) K;
NumMod = (DIMENSION FamiF.Cal ) + 1 ;
Mess 'Mode ' &It_m ' et ' NumMod ' : ' Pro_f;
FamiG.Cal.&It_m.u = FamiG.Cal.&It_m.u + (g_tmps.u * Pro_f);
FamiG.Cal.&It_m.v = FamiG.Cal.&It_m.v + (g_tmps.v * Pro_f);
FamiG.Cal.&It_m.w = FamiG.Cal.&It_m.w + (g_tmps.w * Pro_f);
f_espa = f_espa - (FamiF.Cal.&It_m * Pro_f);
NorInter = (AASZ f_espa K);
Mess 'NORME = ' NorInter;
FIN It_m;
RESPRO f_espa ;
RESPRO FamiG ;
FINPROC;
$$$$ AAFZ
DEBPROC AAFZ M C K CL_A Ttot schema CHA dt It_m ;
g_init = TABLE;
g_init.w = PROG En_Nb_Re * 1. ;
g_init.v = PROG 0. PAS dt Ttot ;
g_init.u = ((g_init.v)**2) /2 ;
TabEvoNL = TABLE;
g_tmps = g_init;
*gev_ = TABLE;
*fev_ = TABLE;
REPETER It 10;
Mess '  ' &It;
f_espa = AABZ M C K CL_A CHA dt g_tmps It_m ;
Nor_f = AASZ f_espa K;
f_espa = f_espa/Nor_f ;
*fev_.&It = f_espa ;
g_tmps TabEvoNL = AAEZ M C K Ttot schema CHA dt f_espa It_m ;
*gev_.&It = g_tmps ;
Bool = &It > 1 ;
Si Bool;
BoolConv = AAHZ f_espa g_tmps f_prec g_prec;
Si BoolConv;
QUIT It;
FinSi ;
FinSi ;
f_prec = f_espa;
g_prec = g_tmps;
Fin It ;
Mess '___';
RESPRO f_espa ;
RESPRO g_tmps ;
FINPROC;
$$$$ AABZ
DEBPROC AABZ M C K CL_A CHA dt g It_m ;
Int1 = AADZ g.u g.u dt ;
Int2 = AADZ g.v g.u dt ;
Int3 = AADZ g.w g.u dt ;
Premier = (Int1*K) et (Int2*C) et (Int3*M);
* Contribution des efforts
NbCharg = DIMENSION CHA ;
Si (NbCharg > 0);
REPETER It NbCharg ;
CHA_i = EXTR CHA CHAR &It ;
CHP_i = EXTR CHA_i CHAM ;
EVO_i = EXTR CHA_i EVOL ;
CH_ord = EXTR EVO_i ORDO ;
CH_abs = EXTR EVO_i ABSC ;
Int = AADZ CH_ord g.u CH_abs ;
Si (&It ega 1) ;
Second = (CHP_i*Int) ;
SiNon ;
Second = Second + (CHP_i*Int) ;
FinSi ;
FIN It ;
FinSi ;
Si ( (DIME TabEvoNL) > 0) ;
REPETER It_NL Nb_NL ;
FOR_NL = (Pb.Tab_NL.&It_NL.effo) ;
CH_ord = EXTR (TabEvoNL.&It_NL) ORDO ;
Int = AADZ CH_ord g.u Vec_T ;
Si ( (NbCharg > 0) et (&It_NL ega 1) );
Second = Second + (FOR_NL*Int) ;
SiNon ;
Second = (FOR_NL*Int) ;
FinSi ;
Fin It_NL ;
FinSi ;
* La somme sur les modes precedents
FamiFTot FamiGTot = AAUZ (It_m-1) ;
TailFami = DIMENSION FamiFTot;
Si (TailFami > 0);
Som1 = 0;
Som2 = 0;
Som3 = 0;
REPETER Mod TailFami;
gk = FamiGTot.&Mod;
fk = FamiFTot.&Mod;
g_gk   = AADZ g.u gk.u dt ;
g_gkp  = AADZ g.u gk.v dt ;
g_gkpp = AADZ g.u gk.w dt ;
Som1 = Som1 + (g_gk   * fk);
Som2 = Som2 + (g_gkp  * fk);
Som3 = Som3 + (g_gkpp * fk);
Fin Mod;
Si (NbCharg > 0);
Second = Second - ( (K*Som1) + (C*Som2) + (M*Som3) ) ;
SiNon ;
Second =  (-1) * ( (K*Som1) + (C*Som2) + (M*Som3) ) ;
FinSi ;
FinSi ;
Si ((NON (NbCharg > 0)) ET (NON (TailFami > 0)));
Mess 'il n y a ni effort ni deplacements imposes';
Mess '--------------------------------------------';
list CHA.1;
FinSi ;
* Resolution
Premier = Premier ET CL_A;
f = RESO Premier Second;
RESPRO f;
FINPROC;
$$$$ AAEZ
DEBPROC AAEZ M C K Ttot schema CHA dt f It_m ;
* Creer un procedure pour le schema
alpha = 0.;
beta = 1./4;
gamma = 1./2;
* Cette partie ne pourra plus etre hors de la boucle en non lineaire
Prem_g = XTMX f_espa K ;
Prem_gp = XTMX f_espa C ;
Prem_gpp = XTMX f_espa M ;
NbCharg = DIMENSION CHA ;
Bool1 = (NbCharg > 0);
Si Bool1;
REPETER It_T NbCharg ;
CHA_i = EXTR CHA CHAR &It_T ;
CHP_i = EXTR CHA_i CHAM ;
FOR_proj = XTY CHP_i f LFOR L_f;
EVO_i = EXTR CHA_i EVOL ;
Si (&It_T ega 1) ;
FOR_EVO = EVO_i*FOR_proj ;
SiNon ;
FOR_EVO = FOR_EVO + (EVO_i * FOR_proj) ;
FinSi ;
FIN It_T ;
F_Hist = EXTR FOR_EVO ORDO ;
F_Hist2 = (PROG (EXTR F_Hist 1)) et F_Hist;
F_Hist2 = ENLEVER F_Hist2 (DIMENSION F_Hist2);
Second = ((1+alpha)*F_Hist) - (alpha*F_Hist2);
FinSi ;
Si ( Nb_NL > 0) ;
FNL_proj = TABLE ;
UNL_proj = TABLE ;
TabLisNL = TABLE ;
REPETER It_NL Nb_NL ;
FNL_proj.&It_NL = XTY (Pb.Tab_NL.&It_NL.effo) f LFOR L_f ;
Si ( EXISTE (Pb.Tab_NL.&It_NL) Poi_int ) ;
UNL_proj.&It_NL = (EXTR f (Pb.Tab_NL.&It_NL.Dir_int)
(Pb.Tab_NL.&It_NL.Poi_int)) * (Pb.Tab_NL.&It_NL.fac_int) ;
SiNon ;
UNL_proj.&It_NL = XTY (Pb.Tab_NL.&It_NL.ch_depen) f LFOR L_f;
FinSi ;
TabLisNL.&It_NL = PROG ;
Fin It_NL ;
FinSi ;
FamiFTot FamiGTot = AAUZ (It_m-1) ;
* Contribution des modes precendents
TailFami = DIMENSION FamiFTot;
Si (TailFami > 0);
REPETER Mod TailFami;
gk = FamiGTot.&Mod;
fk = FamiFTot.&Mod;
f_K_fk = YTMX f fk K;
f_C_fk = YTMX f fk C;
f_M_fk = YTMX f fk M;
Si (&Mod ega 1) ;
ModsPrec = (f_K_fk * gk.u) + (f_C_fk * gk.v) + (f_M_fk * gk.w) ;
SiNon ;
ModsPrec = ModsPrec +
(f_K_fk * gk.u) + (f_C_fk * gk.v) + (f_M_fk * gk.w);
FinSi ;
Fin Mod;
Si Bool1;
Second = Second - ModsPrec;
SiNon ;
Second = (-1) * ModsPrec;
FinSi ;
FinSi ;
Si ((NON Bool1) ET (NON (TailFami > 0)));
Mess 'il n y a ni effort ni deplacements imposes';
Mess '--------------------------------------------';
list CHA.1;
FinSi ;
g = PROG ;
gp = PROG ;
gpp = PROG ;
REPETER It_T En_Nb_Re;
Si (&It_T ega 1);
g_t = 0. ;
gp_t = 0. ;
g__tm1 = 0. ;
gp__tm1 = 0. ;
gpp_t = 0. ;
g_pred = 0. ;
gp_pred = 0. ;
SiNon ;
g_pred = g_t + ((1+alpha)*((dt*gp_t) + ((dt**2)*(0.5-beta)*gpp_t)));
gp_pred = gp_t + ((1+alpha)*dt*(1-gamma)*gpp_t ) ;
FinSi ;
SecondT = EXTR Second &It_T ;
Si ( Nb_NL > 0) ;
gpp_t gp_t g_t = ABPZ SecondT &It_T 'PGD' PGDPt_Fx ;
SiNon ; 
gpp_t gp_t g_t = ABJZ SecondT &It_T;
FinSi ;
g =   g   et (PROG g_t  ) ;
gp =  gp  et (PROG gp_t ) ;
gpp = gpp et (PROG gpp_t) ;
g__tm1 = g_t ;
gp__tm1 = gp_t ;
Fin It_T ;
g_tmps = TABLE;
g_tmps.u = g;
g_tmps.v = gp;
g_tmps.w = gpp;
RESPRO g_tmps;
TabEvoNL = TABLE ;
Si ( Nb_NL > 0) ;
REPETER It_NL Nb_NL ;
TabEvoNL.&It_NL = EVOL MANU T Vec_T F(T) (TabLisNL.&It_NL) ;
Fin It_NL ;
FinSi ;
RESPRO TabEvoNL ;
FINPROC;
$$$$ ABJZ
DEBPROC ABJZ Seco_0_T*FLOTTANT It_0_T*ENTIER;
gpp_t_pr = gpp_t;
gpp_0_t = (Seco_0_T - ((Prem_g*g_pred)+(Prem_gp*gp_pred)))/Prem_gpp;
Si (It_0_T ega 1) ;
g_0_t = 0 ;
gp_0_t = 0 ;
SiNon ;
g_0_t = g__tm1 + (dt*gp__tm1)       
+ ((dt**2)*(0.5-beta)*gpp_t_pr)
+ (beta*(dt**2)*gpp_0_t) ;
gp_0_t = gp__tm1 + (dt*(1-gamma)*gpp_t_pr) + (dt*gamma*gpp_0_t) ;
FinSi ;
RESPRO gpp_0_t ;
RESPRO gp_0_t ;
RESPRO g_0_t ;
FINPROC;
$$$$ AARZ
DEBPROC AARZ NbModCal*Entier;
Val_INI = 0;
Si ((XTMX U0 K) neg 0);
Val_INI = Val_INI + 1;
FamiF.INI.Val_INI = U0;
Nor_f = AASZ (FamiF.INI.Val_INI) K;
FamiF.INI.Val_INI = (FamiF.INI.Val_INI) / Nor_f ;
FamiG.INI.Val_INI = TABLE;
FamiG.INI.Val_INI .u = PROG En_Nb_Re * Nor_f ;
FamiG.INI.Val_INI .v = PROG En_Nb_Re * 0. ;
FamiG.INI.Val_INI .w = PROG En_Nb_Re * 0. ;
FinSi ;
Si ((XTMX V0 K) neg 0);
Val_INI = Val_INI + 1;
FamiF.INI.Val_INI = V0;
Nor_f = AASZ (FamiF.INI.Val_INI) K ;
FamiF.INI.Val_INI = (FamiF.INI.Val_INI) / Nor_f ;
FamiG.INI.Val_INI = TABLE;
FamiG.INI.Val_INI .u = PROG 0. PAS dt Ttot ;
FamiG.INI.Val_INI .u = (FamiG.INI.Val_INI .u) * Nor_f ;
FamiG.INI.Val_INI .v = PROG En_Nb_Re * Nor_f ;
FamiG.INI.Val_INI .w = PROG En_Nb_Re * 0. ;
FinSi ;
REPETER It_m NbModCal;
Bool_1 = (OPT0.Orth) ET (&It_m > 1);
Bool_2 = Bool_1 et (OPT0.Upda) ;
REPETER Ort -1;
f_espa g_tmps = AAFZ M C K CL_A Ttot schema CHA_TOT dt &It_m;
Si Bool_1;
f_espa FamiG = AAQZ;
N_f_espa = AASZ f_espa  K ;
Mess 'f_espaNEW = ' N_f_espa ;
Si (N_f_espa < 0.1);
Mess 'Mode rejete';
SiNon ;
f_espa = f_espa/N_f_espa;
QUITTER Ort;
FinSi ;
SiNon ;
QUITTER Ort;
FinSi ;
Fin Ort;
FamiF.Cal.&It_m = f_espa;
Si Bool_2;
FamiG.Cal= AAVZ;
SiNon ;
FamiG.Cal.&It_m = g_tmps;
FinSi ;
ErrDepl ErrGlob = AAXZ DirPriv VRAI &It_m;
Mess 'ErrDepl=' ErrDepl 'ErrGlob=' ErrGlob;
Fin It_m;
FINPROC;
$$$$ AAVZ
DEBPROC AAVZ;
* Maillage necessaire pour creer les objets de calculs
*   Rigidite et Second membre
Si ((VALE 'DIME') > 2) ;
P_1 = 0. 0. 0. ;
SiNon ;
P_1 = 0. 0. ;
FinSi ;
MAI1 = MANU POI1 P_1  ;
TaiSys = DIMENSION FamiF.Cal;
Lis1Up = PROG ((TaiSys*3)**2)* 0. ;
Lis1Init = PROG (TaiSys**2)* 0. ;
LISU_ini = MOTS ;
LISF_ini = MOTS ;
REPE BCL1M TaiSys ;
Num = ((3 * (&BCL1M - 1) ) + 1);
COU1 = CHAIN 'U' Num ;
COF1 = CHAIN 'F' Num ;
LISU_ini = LISU_ini ET (MOTS COU1) ;
LISF_ini = LISF_ini ET (MOTS COF1) ;
FIN BCL1M ;
Tab_Mat = TABLE;
Tab_Mat.1 = M ;
Tab_Mat.2 = C ;
Tab_Mat.3 = K ;
LISU_tot = MOTS ;
LISF_tot = MOTS ;
REPE BCL1M (TaiSys*3) ;
COU1 = CHAIN 'U' &BCL1M ;
COF1 = CHAIN 'F' &BCL1M ;
LISU_tot = LISU_tot ET (MOTS COU1) ;
LISF_tot = LISF_tot ET (MOTS COF1) ;
FIN BCL1M ;
Cha_proj = TABLE;
Cha_proj.Ffi = TABLE;
Cha_proj.F_t = TABLE;
Cha_proj.Ff_init = TABLE;
NL_proj = TABLE;
NL_proj.Ffi = TABLE;
NL_proj.Ff_init = TABLE;
NL_proj.Dfi = TABLE;
NL_proj.Eva_Impo = TABLE;
L_F_NL = PROG ;
* Contribution des efforts
NbCharg = DIMENSION CHA_TOT ;
Si (NbCharg > 0);
REPETER It_1 NbCharg ;
CHA_i = EXTR CHA_TOT CHAR &It_1 ;
CHP_i = EXTR CHA_i CHAM ;
EVO_i = EXTR CHA_i EVOL;
Cha_proj.F_t.&It_1 = EXTR EVO_i ORDO ;
Lis_Ffi = PROG;
Lis_Init = PROG;
REPETER It_2 TaiSys;
f_i = FamiF.Cal.&It_2;
FOR_proj = XTY CHP_i f_i LFOR L_f;
Lis_Init = Lis_Init ET (PROG FOR_proj);
Lis_Ffi = Lis_Ffi ET (PROG FOR_proj 0 0);
FIN It_2;
* Modifier , passer d une liste a un chpoint
CHP1 = MANU 'CHPO' MAI1 LISF_ini Lis_Init;
Cha_proj.Ff_init.&It_1 = CHP1;
CHP1 = MANU 'CHPO' MAI1 LISF_tot Lis_Ffi;
Cha_proj.Ffi.&It_1 = CHP1;
FIN It_1 ;
FinSi ;
* Contribution des modes initiaux et imposes
FamiFIni FamiGIni = AAUZ 0 ;
NbModIni = DIMENSION FamiFIni ;
Si (NbModIni > 0) ;
LIS_V_1 = MOTS 'fMf' 'fCf' 'fKf';
LIS_V_2 = MOTS 'g_A' 'g_V' 'g_U';
Tab_Ini = TABLE ;
REPETER It_1 NbModIni ;
Tab_Ini.&It_1 = TABLE ;
f_ini = FamiFIni.&It_1 ;
REPETER It_2 TaiSys ;
Lis_Vec = PROG ;
f_ligne = FamiF.Cal.&It_2 ;
REPETER It_3 3 ;
Val1 = YTMX f_ini f_ligne Tab_Mat.&It_3 ;
Lis_Vec = Lis_Vec ET (PROG Val1) ;
Fin It_3;
Tab_Ini.&It_1 .&It_2 =  MANU 'CHPO' MAI1 LIS_V_1 Lis_Vec ;
FIN It_2;
Tab_Ini.&It_1.g = FamiGIni.&It_1 ;
Fin It_1 ;
FinSi ;
* Contribution Non Lineaire
Si (Nb_NL > 0) ;
TabLisNL = TABLE ;
REPETER It_NL Nb_NL ;
TabLisNL.&It_NL = PROG ;
Lis_Ffi = PROG;
Lis_Init = PROG;
Lis_Dfi = PROG ;
REPETER It_2 TaiSys;
f_i = FamiF.Cal.&It_2;
FNL_proj = XTY (Pb.Tab_NL.&It_NL.effo) f_i LFOR L_f ;
Si ( EXISTE (Pb.Tab_NL.&It_NL) Poi_int ) ;
UNL_proj = (EXTR f_i (Pb.Tab_NL.&It_NL.Dir_int)
(Pb.Tab_NL.&It_NL.Poi_int)) * (Pb.Tab_NL.&It_NL.fac_int)  ;
SiNon ;
UNL_proj = XTY (Pb.Tab_NL.&It_NL.ch_depen) f_i LFOR L_f;
FinSi ;
Lis_Init = Lis_Init ET (PROG FNL_proj);
Lis_Ffi = Lis_Ffi ET (PROG FNL_proj 0 0);
Lis_Dfi = Lis_Dfi ET (PROG UNL_proj);
FIN It_2;
Si (NbModIni > 0) ;
NL_proj.Eva_Impo.&It_NL = TABLE;
REPETER It_Impo NbModIni ;
NL_proj.Eva_Impo.&It_NL.&It_Impo = TABLE;
Si ( EXISTE (Pb.Tab_NL.&It_NL) Poi_int ) ;
UNL_proj = (EXTR (FamiFIni.&It_Impo) (Pb.Tab_NL.&It_NL.Dir_int)
(Pb.Tab_NL.&It_NL.Poi_int)) * (Pb.Tab_NL.&It_NL.fac_int) ;
SiNon ;
UNL_proj = XTY (Pb.Tab_NL.&It_NL.ch_depen) (FamiFIni.&It_Impo) LFOR L_f;
FinSi ;
NL_proj.Eva_Impo.&It_NL.&It_Impo.u = UNL_proj * (FamiGIni.&It_Impo.u) ;
NL_proj.Eva_Impo.&It_NL.&It_Impo.v = UNL_proj * (FamiGIni.&It_Impo.v) ;
Fin It_Impo ;
FinSi ;
CHP1 = MANU 'CHPO' MAI1 LISF_ini Lis_Init;
NL_proj.Ff_init.&It_NL = CHP1;
CHP1 = MANU 'CHPO' MAI1 LISF_tot Lis_Ffi;
NL_proj.Ffi.&It_NL = CHP1;
CHP1 = MANU 'CHPO' MAI1 LISU_ini Lis_Dfi;
NL_proj.Dfi.&It_NL = CHP1;
FIN It_NL ;
FinSi ;
* Matrice Pij =
* [  fi*K*fj     fi*C*fj     fi*M*fj ;
*   -dt*gamma       1           0    ;
*   -beta*dt^2      0           1   ];
* Matrice des Pij assembles
REPETER It_1 TaiSys;
REPETER It_2 3;
Ind_Lign = ((&It_1-1)*3) + (&It_2-1) + 1;
Si (&It_2 ega 1);
REPETER It_3 TaiSys;
f_ligne = FamiF.Cal.&It_1;
REPETER It_4 3;
f_colo = FamiF.Cal.&It_3;
ind_List = (Ind_Lign-1)*(TaiSys*3)
+ ((&It_3-1)*3) + &It_4;
Si (&It_4 ega 1);
Val1 = YTMX f_colo f_ligne M ;
ind_Init = ((&It_1 - 1) *TaiSys)
+ (&It_3 - 1) + 1 ;
REMPLACER Lis1Init ind_Init Val1;
FinSi ;
Si (&It_4 ega 2);
Val1 = YTMX f_colo f_ligne C ;
FinSi ;
Si (&It_4 ega 3);
Val1 = YTMX f_colo f_ligne K ;
FinSi ;
REMPLACER Lis1Up ind_List Val1;
FIN It_4;
FIN It_3;
FinSi ;
Si (&It_2 ega 2);
ind_List = (Ind_Lign-1)*(TaiSys*3) + (Ind_Lign-2) + 1;
Val1 = (-1)*(dt*gamma);
REMPLACER Lis1Up ind_List Val1;
ind_List = ind_List + 1;
REMPLACER Lis1Up ind_List 1.;
FinSi ;
Si (&It_2 ega 3);
ind_List = (Ind_Lign-1)*(TaiSys*3) + (Ind_Lign-3) + 1;
Val1 = (-1)*(beta*(dt**2));
REMPLACER Lis1Up ind_List Val1;
ind_List = ind_List + 2;
REMPLACER Lis1Up ind_List 1.;
FinSi ;
FIN It_2;
FIN It_1;
PremInit = MANU 'RIGIDITE' 'TYPE' 'RIGIDITE' MAI1 LISU_ini
'DUAL' LISF_ini 'QUEL' Lis1Init ;
PremMemb = MANU 'RIGIDITE' 'TYPE' 'RIGIDITE' MAI1 LISU_tot
'DUAL' LISF_tot 'QUEL' Lis1Up ;
New_Fami = TABLE;
REPETER It_1 TaiSys;
New_Fami.&It_1 = TABLE;
FIN It_1;
REPETER It_T En_Nb_Re;
Si (&It_T ega 1);
* Assemblage du second membre
Si (NbCharg > 0);
SecoMemb = AAYZ 1 (Cha_proj.Ff_init) ;
FinSi ;
Si (NbModIni > 0) ;
CHP1 = AAZZ VRAI LISF_ini ;
Si (NbCharg > 0) ;
SecoMemb = SecoMemb - CHP1 ;
SiNon ;
SecoMemb = (-1) * CHP1 ;
FinSi ;
FinSi ;
Si (Nb_NL > 0) ;
REPETER It_NL Nb_NL ;
CHP_01 FT_NL_T Bool_Max = ABGZ &It_NL &It_T (NL_proj.Ff_init) ;
Si ( &It_NL ega 1) ;
CHP1 = CHP_01 ;
F_NL_T = FT_NL_T;
SiNon ;
CHP1 = CHP_01 + CHP1 ;
F_NL_T = FT_NL_T + F_NL_T;
FinSi ;
Fin It_NL ;
L_F_NL = L_F_NL et (PROG F_NL_T);
Bool_1 = ( OU (NbCharg > 0) (NbModIni > 0) ) ;
Si Bool_1 ;
SecoMemb = SecoMemb + CHP1 ;
SiNon ;
SecoMemb = CHP1 ;
FinSi ;
FinSi ;
Vec_GIni = RESO PremInit SecoMemb;
REPETER It_1 TaiSys;
mot1 = EXTR LISU_ini &It_1;
New_Fami.&It_1.w = PROG (EXTR Vec_GIni mot1 P_1);
New_Fami.&It_1.v = PROG 0;
New_Fami.&It_1.u = PROG 0;
FIN It_1;
SiNon ; 
Si (NbCharg > 0);
SecoMemb = AAYZ &It_T (Cha_proj.Ffi) ;
FinSi ;
Si (NbModIni > 0) ;
CHP1 = AAZZ FAUX LISF_tot ;
Si (NbCharg > 0) ;
SecoMemb = SecoMemb - CHP1 ;
SiNon ;
SecoMemb = (-1) * CHP1 ;
FinSi ;
FinSi ;
Lis_Seco = PROG;
REPETER It_1 TaiSys;
g_W_m1 = EXTR New_Fami.&It_1.w (&It_T - 1);
g_V_m1 = EXTR New_Fami.&It_1.v (&It_T - 1);
g_U_m1 = EXTR New_Fami.&It_1.u (&It_T - 1);
pred_V = (g_V_m1 + ((dt*(1-gamma)) * g_W_m1));
pred_U = (g_U_m1 + (dt*g_V_m1) + ((dt**2)*(0.5-beta)*g_W_m1));
Lis_Seco = Lis_Seco ET (PROG 0. pred_V pred_U);
FIN It_1;
Seco_2 = MANU 'CHPO' MAI1 LISF_tot Lis_Seco;
SecoMemb = SecoMemb + Seco_2;
Si (Nb_NL > 0) ;
Vec_G_T = ABPZ SecoMemb &It_T 'Upd' Up_Pt_Fx ;
SiNon ; 
Vec_G_T = RESO PremMemb SecoMemb;
FinSi ;
REPETER It_1 TaiSys;
mot1 = EXTR LISU_tot (((&It_1 - 1) * 3) + 1);
New_Fami.&It_1.w = New_Fami.&It_1.w ET (PROG (EXTR Vec_G_T mot1 P_1));
mot1 = EXTR LISU_tot (((&It_1 - 1) * 3) + 2);
New_Fami.&It_1.v = New_Fami.&It_1.v ET (PROG (EXTR Vec_G_T mot1 P_1));
mot1 = EXTR LISU_tot (((&It_1 - 1) * 3) + 3);
New_Fami.&It_1.u = New_Fami.&It_1.u ET (PROG (EXTR Vec_G_T mot1 P_1));
FIN It_1;
FinSi ;
Fin It_T ;
RESPRO New_Fami;
FINPROC;
$$$$ AAKZ
DEBPROC AAKZ AffMods*ListEnti AffSolu*ListEnti Pt_Aff*Point
Coord;
NbMod = DIMENSION FamiF.Cal
+ (DIME FamiF.Ini)
+ (DIME FamiF.Imp);
NbMax = MAXI (AffMods et AffSolu);
Si (NbMax > NbMod);
Mess 'Il n y a que ' NbMod ' modes' ;
opti donn 5;
FinSi ;
NbModCal = (NbMax - (DIME FamiF.Ini)) - (DIME FamiF.Imp);
FamiFTot FamiGTot = AAUZ NbModCal ;
Sol_dir = PROG;
REPE It En_Nb_Re;
It_T = &It - 1;
Sol_dir = Sol_dir ET (PROG (EXTR Solu1.U.It_T Coord Pt_Aff));
FIN It;
Evol_dir = EVOL MANU Vec_T Sol_dir ;
* Sortie Fichier
*opti sort (chain 'Direct' ) ;
*sort exce (Evol_dir) sepa VIRG;
Sol_k = TABLE;
Mod_k = TABLE;
Si (NbMax > 0);
REPETER It2 NbMax;
Val = EXTR FamiFTot.&It2 Coord Pt_Aff;
Sol_PGD = Val * FamiGTot.&It2.u ;
Mod_k.&It2 = Sol_PGD;
Si (&It2 > 1);
It_prec = &It2 - 1;
Sol_k.&It2 = Sol_k.It_prec + Mod_k.&It2 ;
SiNon ;
Sol_k.&It2 = Sol_PGD;
FinSi ;
FIN It2;
SiNon;
Dess Evol_dir;
Si (Nb_NL ega 1) ;
Si ( Pt_Aff ega (Pb.Tab_NL.1 .Poi_int) ) ;
Si (EGA Coord (Pb.Tab_NL.1 .Dir_int) );
Var_NL = (Pb.Tab_NL.1 .fac_int) * Sol_dir ;
Eff_NL = ABCZ (Pb.Tab_NL.1) Var_NL ;
Evo_Eff = EVOL Roug MANU Vec_T Eff_NL ;
* Sortie Fichier
*opti sort (chain 'EffortNonLinDir' ) ;
*sort exce (Evo_Eff) sepa VIRG;
DESS Evo_Eff ;
FinSi ;
FinSi ;
FinSi ;
FinSi;
Evo_k = TABLE;
LMot = MOTS 'ROUG' 'BLEU' 'VERT' 'JAUN' 'VIOL' 'TURQ';
* Affichage des Solutions
Si ( (DIMENSION AffSolu) > 0);
REPETER It (MINI ((DIMENSION AffSolu) et 6));
col = EXTR LMot &It;
num = (EXTR AffSolu &It);
Evo_k.&It = EVOL col MANU Vec_T Sol_k.num;
Si (&It ega 1) ;
Tot = Evol_dir et Evo_k.&It;
SiNon ;
Tot = Tot et Evo_k.&It;
FinSi ;
* Sortie Fichier
*opti sort (chain 'SoluPGD' &It ) ;
*sort exce (Evo_k.&It) sepa VIRG;
Fin It;
DESS Tot ;
FinSi ;
* Affichage des modes
Si ( (DIMENSION AffMods) > 0);
REPETER It (MINI ((DIMENSION AffMods) et 6));
col = EXTR LMot &It;
num = EXTR AffMods &It;
Evo_k.&It = EVOL col MANU Vec_T Mod_k.num ;
Si (&It ega 1) ;
Tot = Evol_dir et Evo_k.&It;
SiNon ;
Tot = Tot et Evo_k.&It;
FinSi ;
* Sortie Fichier
*opti sort (chain 'ModePGD' &It ) ;
*sort exce (Evo_k.&It) sepa VIRG;
Fin It;
DESS Tot ;
*XBOR 0. 1e-2 YBOR -4e-3 1e-3;
FinSi ;
Si (NbMax > 0) ;
Si (Nb_NL ega 1) ;
Si ( Pt_Aff ega (Pb.Tab_NL.1 .Poi_int) ) ;
Si (EGA Coord (Pb.Tab_NL.1 .Dir_int) );
Var_NL = (Pb.Tab_NL.1 .fac_int) * Sol_k.NbMax ;
Eff_NL = ABCZ (Pb.Tab_NL.1) Var_NL ;
Evo_Eff = EVOL Roug MANU Vec_T Eff_NL ;
* Sortie Fichier
*opti sort (chain 'EffortNonLinPGD' ) ;
*sort exce (Evo_Eff) sepa VIRG;
DESS Evo_Eff ;
FinSi ;
FinSi ;
FinSi ;
FinSi ;
FINPROC;
$$$$ AAOZ
DEBPROC AAOZ AffMods*ListEnti;
NbMod = DIMENSION FamiF.Cal;
NbMax = MAXI AffMods;
Si (NbMax > NbMod);
Mess 'Il n y a que ' NbMod ' modes';
opti donn 5;
FinSi ;
DEF0 = DEFO (Pb.geo) 0 (FamiF.Cal.1);
trac DEF0;
LMot = MOTS 'ROUG' 'BLEU' 'VERT' 'JAUN' 'VIOL' 'TURQ';
REPETER It (DIMENSION AffMods);
col = EXTR LMot &It;
NumMod = EXTR AffMods &It;
Si (&It ega 1) ;
DEFA = (DEF0 ET (DEFO Pb.geo FamiF.Cal.NumMod col));
Trac DEFA;
SiNon ;
DEFA = (DEFA ET (DEFO Pb.geo FamiF.Cal.NumMod col));
TRAC DEFA;
FinSi ;
Fin It;
*trac DEFA;
FINPROC;
$$$$ AAPZ
DEBPROC AAPZ Coord/MOT Bool2/LOGIQUE;
Bool1 = EXISTE Coord;
Si (EXISTE Bool2);
Bool3=Bool2;
SiNon ;
Bool3=(NON Bool1);
FinSi ;
ErrDepMo = PROG;
ErrParMo = PROG;
EneTot = PROG;
REPETER It_m NbModCal;
rec_sol = AALZ &It_m;
Err = AAMZ Solu1.u rec_sol.u;
ErrMax = PROG;
Out_Err = AAWZ (&It_m ega 1);
Si Bool1;
ErrDepMo = ErrDepMo ET Out_Err.MaxErr;
FinSi ;
Si Bool3;
Si (&It_m ega 1) ;
EneTotEV = EVOL MANU T Vec_T Errr Out_Err.Tot ;
FinSi ;
ErrTotEV = EVOL MANU T Vec_T Errr Out_Err.3 ;
ErrParMo = ErrParMo ET (SOMM ErrTotEV);
FinSi ;
Si (&It_m ega 1) ;
SolAmpli = Out_Err.SolAmpli ;
FinSi ;
FIN It_m;
Si (NbModCal ega 1);
LMod = PROG 1;
SiNon ;
LMod = (PROG 1 PAS 1 NbModCal);
FinSi ;
Si Bool1;
ErrDepMo = ErrDepMo / SolAmpli;
Mess 'Erreur Relative en Deplacement sur ' Coord
' en fonction du nombre de mode';
Mess '___________________________________ :';
list (EVOL MANU Mode LMod Erreur ErrDepMo);
RESPRO ErrDepMo;
FinSi ;
Si Bool3;
ErrParMo = ErrParMo / (EXTR (SOMM EneTotEV) 1) ;
Mess 'Erreur Energetique en fonction du nombre de mode';
Mess '___________________________________ :';
list (EVOL MANU Mode LMod Erreur ErrParMo);
RESPRO ErrParMo;
FinSi ;
FINPROC;
$$$$ AAWZ
DEBPROC AAWZ Bool4*LOGIQUE;
* Reference : Solu1.u
* Difference : Err
* Bool4 : Si Vrai, calcul sur la Reference : Amplitude et energie Totale
Out_Err = TABLE;
ErrEne = PROG;
ErrTotM = -0.1;
REPE IT_T En_Nb_Re;
in_T = &IT_T - 1;
Si Bool1;
ErrTotM = MAXI ( PROG
(MAXI (ABS ((EXCO Coord Err.in_T))))
ErrTotM
);
Si Bool4;
SoluT = EXCO Coord Solu1.u.in_T;
Si (&IT_T ega 1) ;
Max_Dep = MAXI SoluT;
Min_Dep = MINI SoluT;
SiNon ;
Max_Dep = MAXI ( PROG (MAXI SoluT) Max_Dep );
Min_Dep = MINI ( PROG (MINI SoluT) Min_Dep );
FinSi ;
FinSi ;
FinSi ;
Si Bool3;
ErrEneT = XTMX Err.in_T K;
ErrEne = ErrEne et ErrEneT;
Si Bool4 ;
EneTotT = XTMX Solu1.u.in_T K;
EneTot = EneTot et EneTotT;
FinSi ;
FinSi ;
FIN IT_T;
Si Bool1;
Out_Err.MaxErr = ErrTotM;
Si Bool4 ;
Out_Err.SolAmpli = Max_Dep - Min_Dep;
FinSi ;
FinSi ;
Si Bool3;
Si Bool4 ;
Out_Err.Tot = EneTot;
FinSi ;
Out_Err.3 = ErrEne;
FinSi ;
RESPRO Out_Err;
FINPROC;
$$$$ AAXZ
DEBPROC AAXZ Coord/MOT Bool2/LOGIQUE Mode/ENTIER
Ref_Cal/TABLE Sol_Cal/Table;
Bool1 = EXISTE Coord;
Si (EXISTE Bool2);
Bool3=Bool2;
SiNon ;
Bool3=(NON Bool1);
FinSi ;
EneTot = PROG;
Si (EXISTE Mode) ;
rec_sol = AALZ Mode;
Err = AAMZ Solu1.u rec_sol.u;
SiNon ;
Err = AAMZ Ref_Cal.u Sol_Cal.u;
FinSi ;
Out_Err = AAWZ VRAI;
Si Bool1;
ErrDepl = Out_Err.MaxErr;
ErrDepl = ErrDepl / Out_Err.SolAmpli;
RESPRO ErrDepl;
FinSi ;
Si Bool3;
EneTotEV = EVOL MANU T Vec_T Errr Out_Err.Tot ;
ErrTotEV = EVOL MANU T Vec_T Errr Out_Err.3 ;
ErrGlob = (EXTR (SOMM ErrTotEV) 1) / (EXTR (SOMM EneTotEV) 1) ;
RESPRO ErrGlob;
FinSi ;
FINPROC;
$$$$ AAMZ
DEBPROC AAMZ Sol_1 Sol_2 ;
Sol = TABLE ;
REPETER It En_Nb_Re ;
It_T = &It - 1 ;
Sol.It_T = Sol_1.It_T - Sol_2.It_T ;
Fin It ;
RESPRO Sol ;
FINPROC;
$$$$ AALZ
DEBPROC AALZ It_m*Entier;
Sol = TABLE ;
U_sol = TABLE;
V_sol = TABLE;
A_sol = TABLE;
FamiFTot FamiGTot = AAUZ It_m ;
NbMod = (DIME FamiFTot);
REPETER It2 NbMod;
REPETER It En_Nb_Re;
It_T = &It - 1;
Si (&It2 ega 1) ;
U_sol.It_T = FamiFTot.&It2 * (EXTR FamiGTot.&It2.u &It) ;
V_sol.It_T = FamiFTot.&It2 * (EXTR FamiGTot.&It2.v &It) ;
A_sol.It_T = FamiFTot.&It2 * (EXTR FamiGTot.&It2.w &It) ;
SiNon ;
U_sol.It_T = U_sol.It_T + (FamiFTot.&It2 * (EXTR FamiGTot.&It2.u &It)) ;
V_sol.It_T = V_sol.It_T + (FamiFTot.&It2 * (EXTR FamiGTot.&It2.v &It)) ;
A_sol.It_T = A_sol.It_T + (FamiFTot.&It2 * (EXTR FamiGTot.&It2.w &It)) ;
FinSi ;
Fin It;
FIN It2;
Sol.U = U_sol;
Sol.V = V_sol;
Sol.W = A_sol;
RESPRO Sol;
FINPROC;
$$$$ AANZ
DEBPROC AANZ;
OPTI DIME 3 ELEM qua8 ;
Pb = TABLE;
Cal_T = TABLE;
*---------------------DONNEES---------------------*
*Unites SI
AMP1 = 100.0 ;
LON1 = 0.5 ;
LON2 = 0.02 ;
EP1 = 1e-2;
NUP = 0.3 ;
YOP = 2.1E11 ;
RHOP = 7800.0 ;
*--------------------GEOMETRIE--------------------*
P1 = 0.   0. 0. ;
P2 = LON1 0. 0. ;
P4 = LON1 LON2 0. ;
P5 = 0. LON2 0. ;
L1 = D 20 P1 P2 ;
L2 = D 2  P2 P4 ;
L3 = D 20 P4 P5 ;
L4 = D 2  P5 P1 ;
PouPla = DALL L1 L2 L3 L4 ;
P3 = PouPla POIN PROC (LON1 (LON2/2) 0.);
Pb.geo = PouPla;
ELIM PouPla 0.0001;
Pb.DirPriv = 'UX';
*TRAC PouPla ;
*------DEFINITION DU MODELE ET DU MATERIAU--------*
MOD1 = MODEL PouPla MECANIQUE ELASTIQUE COQ8 ;
MAT1 = MATER MOD1 YOUN YOP NU NUP RHO RHOP ;
CAR1 = CARAC MOD1 EPAI EP1;
MATTOT = MAT1 ET CAR1 ;
*-------MATRICES DE RIGIDITE ET DE MASSE----------*
Pb.K = RIGI MOD1 MATTOT ;
Pb.M = MASS MOD1 MATTOT ;
*--------------CONDITIONS LIMITES-----------------*
CL1 = BLOQ L4 UY UX RZ ;
CL2 = BLOQ PouPla UZ RX RY ;
Pb.CL_TOT= CL1 ET CL2 ;
*--------------Parametres de calcul---------------*
Cal_T.dt = 1e-6;
Cal_T.Ttot = 5e-4;
Pb.T_period = 2.5e-4 ;
En_Nb_Re = AAGZ Cal_T.dt Cal_T.Ttot;
Vec_T = PROG 0. PAS Cal_T.dt Cal_T.Ttot ;
*------------EVOLUTION TEMPORELLE-----------------*
LIS1 = (PROG sinu (1/Pb.T_period) PHAS 270 Vec_T) ;
LIS1 = LIS1 + (PROG En_Nb_Re*1.);
EVT1 = EVOL MANU T Vec_T G(T) LIS1 ;
EVT2 = EVOL MANU T Vec_T G(T) (Vec_T*2) ;
*-----------------CHARGEMENT----------------------*
FOR1 = FORCE FX AMP1 P3 ;
FOR2 = FORCE FX 0. P3 ;
CHA1 = CHAR FORC FOR1 EVT1 ;
CHA2 = CHAR FORC FOR2 EVT2 ;
Pb.CHA_TOT = CHA1 et CHA2;
*------------- Deplacement Initial -------------*
dep_0 = RESO (Pb.K ET Pb.CL_Tot) (For1 * 0.);
Pb.U0  = dep_0;
Pb.V0  = dep_0;
*------------- Non Linearite -------------*
Pb.Tab_NL = TABLE;
Pb.P_intere = P3;
RESPRO Pb;
RESPRO Cal_T;
FINPROC;
$$$$
